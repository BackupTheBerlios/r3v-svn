\documentclass[a4paper,12pt]{article}
\usepackage[latin1]{inputenc}
\usepackage{vmargin}
\usepackage[catalan]{babel}
\usepackage{graphicx}
\usepackage{fancyhdr}
\usepackage{eurosym}

\pagestyle{fancy}

\renewcommand{\baselinestretch}{1.3}

\makeindex

\begin{document}

\tableofcontents

\newpage
\section{Com usar aquesta memòria}
\paragraph{}
%TODO ATECION QUE NO CAMBIE EL NUMERO de secciones
Aquest document està estructurat en dotze seccions bàsiques. El document segueix una forma lògica i seqüencial d'explicar els conceptes de forma que no calgui anar endavant i enrera per entendre les idees, per aquesta raó pot semblar que en algun moment s'estigui repetint alguna idea, però serà perquè s'està ampliant l'explicació d'algun concepte. Les seccions de la memòria són:
\begin{enumerate}
\item \textit{Com usar aquesta memòria} - Aquesta secció explica quins continguts es poden trobar a cadascuna de les seccions per tal que el lector pugui decidir si pot saltar-se alguna ja que els conceptes dels quals es parlen ja li són coneguts així com veure quines seccions expliquen coses que ell desconeix i per tant ha d'estar més concentrat en la seva lectura.
\item \textit{Objectius i motivacions} - En aquesta secció es parla dels objectius que es volen assolir amb la realització d'aquest projecte final de carrera així com de les motivacions que han dut a l'alumne a realitzar-lo.
\item \textit{Introducció} - Aquesta part de la memòria introdueix el concepte bàsic en el que es basa el projecte, l'algorisme ROAM, així com un petita explicació de perquè és necessari tenir algorismes per la representació de terrenys de forma dinàmica i explicació dels dos formats de fitxers de dades acceptats, DEM i mapes simples.
\item \textit{Especificació} - Aquesta secció explica tot allò relacionat amb l'especificació: el model conceptual, el model de casos d'ús, els requeriments funcionals i no funcionals, i, una petita descripció informal de cada classe.
\item \textit{Disseny} - Aquesta secció explica el pas de l'especificació al disseny, hi podem trobar un model conceptual modificat per acomodar-se als requeriments juntament amb els diagrames de seqüència.
\item \textit{Implementació} - Aquesta part de la memòria parla de tot allò relacionat amb la programació del projecte però que no forma part ni de l'especificació ni del disseny, com per exemple l'explicació sobre l'eina escollida per la generació automàtica de Makefiles.
\item \textit{Captures de pantalla} - En aquesta secció es poden trobar captures de pantalla de l'aplicació en funcionament per poder fer-se una idea de com funciona.
\item \textit{Recursos i Anàlisi de costos} - En aquesta secció es parla de tot allò que ha fet falta per realitzar el projecte, la seva planificació i l'anàlisi de quan hauria costat desenvolupar aquest projecte en cas que s'haguès tractar d'un projecte comercial.
\item \textit{Conclusions} - Aquesta part de la memòria explica que s'ha après en la realització d'aquest projecte així com possibles modificacions futures que es podrien dur a terme.
\item \textit{Bibliografia} - Aquesta secció és una relació de totes les fonts consultades en la realització del projecte.
\item \textit{Índex de figures} - En aquesta secció hi ha un llistat de totes les figures que es troben a la memòria de forma que en cas que el lector vulgui localitzar una pugui fer-ho de ràpidament.
\item \textit{Annex} - Explicacions sobre temes no estrictament relacionats amb el projecte que poden ser d'ajuda per acabar d'entendre algunes parts de la memòria.
\end{enumerate}

\newpage
\section{Objectius i motivacions}
\paragraph{}
Els continguts relacionats amb els objectius que es volen assolir amb aquest projecte són una sintetització dels requisits expressats a la secció \ref{sec:especificacio}.

\paragraph{}
L'objectiu principal d'aquest projecte és la implementació de l'algorisme ROAM. Per aconseguir-ho tant el projectista com el director del projecte han decidit que la realització del projecte acabarà materialitzant-se en una aplicació amb una llicència de programari lliure. Aquesta aplicació implementarà l'algorisme ROAM així com lectors de diferents formats de fitxers per obtenir dades que puguin fer funcionar l'algorisme i una interfície simple per tal que l'usuari pugui controlar l'aplicació amb facilitat.

\paragraph{}
Com a objectius secundari, es vol que l'aplicació sigui el més portable possible. La portabilitat es vol a dos nivells, el primer dels nivells és la indepèndencia de sistema operatiu, el segon nivell de portabilitat que es desitja és que la interfície gràfica utilitzada per interactuar amb el nucli de l'aplicació que implementa l'algorisme ROAM es pugui canviar sense problemes.

\paragraph{}
Les motivacions per realitzar el projecte són variades, però es poden resumir en els següents punts:
\begin{itemize}
\item El món dels gràfics tridimensionals generats per computador és un món en expansió, no tan sols els videojocs han passat a generar una quantitat de beneficis superior a la del cinema, sinó que hi ha gran demanda d'aplicacions de visualització tridimensional, especialment per a temes mèdics, però també en d'altres camps. Per tant, la realització d'un projecte de final de carrera en aquest camp ajuda a obtenir coneixements sobre aquest camp amb tanta projecció que molt possiblement siguin útils en el futur.
\item El món dels gràfics per computador sempre m'ha interessat de manera especial. Per aquesta raó he cursat quasi totes les asignatures que s'imparteixen a la FIB relacionades amb aquest tema, per tant, aquest camp va ser el primer en el que vaig començar a buscar projectes de final de carrera, un altre camp que també m'interessa, i del qual també vaig mirar els projectes disponibles, és el del món del programari lliure.
\item Un cop analitzats tots els projectes que els professors vinculats a la FIB oferien relacionats amb el món dels gràfics per computador i del programari lliure, vaig anar a parlar amb en Lluís que em va explicar en profunditat de que tractava aquest projecte així com també hem va comunicar que la seva idea era que es desenvolupés com a programari lliure. Això significava que aquest projecte conjugava els dos camps que m'interessaven i, per tant, vaig decidir que si en Lluís estava d'acord en que jo el portés a terme, el projecte de la implementació de l'algorisme ROAM era el projecte que jo desitjava fer.
\end{itemize}

\newpage
\section{Introducció}

\subsection{Representació interactiva de terrenys en 3D}
\paragraph{}
La representació 3D de terrenys pot ser trivial o extremament complicada. Hi ha aplicacions en que el terra és molt poc important i amb un polígon texturat i pla quasi bé ja n'hi ha prou, la majoria de jocs 3D entren dintre d'aquestes aplicacions, jocs de cotxes, arcades 3D, etc. En canvi hi ha un conjunt d'aplicacions on el terreny es part molt important de la visualització, dins d'aquest grup podem trobar els jocs de simulació, sobretot els d'avions, però també jocs de simulació tàctica on el terreny pot permetre amagar-nos dels enemics, etc., evidentment totes les aplicacions que tinguin alguna cosa veure amb els mapes també tenen als terrenys com a part important.
\paragraph{}
A les aplicacions del primer grup, usar un algorisme especial per representar el terreny no té cap sentit, ja que aquest està format per pocs polígons i no cal fer cap optimització per representar-lo. En canvi les aplicacions on l'orografia té un paper important, la visualització del terreny passa a ocupar gran part dels cicles de rellotge que gastarà la nostra aplicació i, per tant, un algorisme optimitzat és necessari. A més a més, en la majoria dels casos no serà únicament necessari per optimizar l'aplicació, sinó que serà completament necessari per tal que l'aplicació pugui funcionar, ja que si volguéssim representar tot el terreny faria falta un nombre ingent de triangles. Per exemple, si fem servir un esquema de representació com el de la figura \ref{fig: ingent}, què és bastant dolent ja que semblaria que el terreny tingués forma de en serreta, però que crea un triangle entre cada punt i els seus dos més propers, per un terreny quadrat de $NxN$ punts, caldrien $2 * (N-1)^2$, cosa que significa que per un terreny de $1000x1000$ punts (res exagerat), caldrien uns dos milions de triangles, una quantitat massa elevada.

\begin{figure}[h]
\centering
\includegraphics{images/ingent.png}
\caption{Esquema de representació de terrenys}
\label{fig: ingent}
\end{figure}

\paragraph{}
Degut a aquesta necessitat d'optimització sorgeixen els algorismes de representació dinàmica de superfícies. Aquests algoritmes intenten aconseguir malles de triangles que representin la superfície de forma tridimensional el més acuradament possible d'una forma eficient. El requisit de l'eficiència ve donada per la interactivitat, ja que com es comenta a l'annex \ref{sec:intvsreal} \textit{(Gràfics interactius vs Gràfics realistes)}, els gràfics interactius necessiten actualitzar la imatge vàries vegades per segon. Per aconseguir tots dos objectius (representació acurada i velocitat), que en principi es contradiuen, el que fa la majoria d'algorismes és generar una malla de triangles potencialment diferent per cada posició de l'observador. D'aquesta manera s'intenta generar una malla de triangles que sigui la òptima per aquesta posició, on òptima significa ser el més acurada possible per allò que és aprop de l'observador i alhora suficientment ràpida per poder-se visualitzar de forma interactiva. La posició de l'observador és clau en aquest aspecte ja que no cal tenir una gran exactitud en la representació de parts de la superfície que es trobin molt lluny de l'observador.

\subsection{L'algorisme ROAM}
\paragraph{}
L'algorisme ROAM \textit{(Real-time Optimally Adapting Meshes)} és un algorisme de visualització dinàmica de terrenys. Com hem explicat en el punt anterior això significa que la malla de triangles utilitzada per representar el terreny es genera tenint en compte la posició de l'observador. A més a més, la malla va evolucionant segons l'observador es mou. ROAM utilitza arbres binaris de triangles (si teniu dubtes de que són podeu consultar la secció \ref{sec:abt}) per representar la superfície.

\subsubsection{Prioritat dels triangles}
\paragraph{}
Per tal d'implementar l'algorisme cal que cada triangle tingui una prioritat associada, així podrem decidir si es prioritari partir un triangle o un altre. El càlcul de la prioritat té dues parts. La primera part és estable respecte a la posició de l'observador mentre que la segona varia segons la posició d'aquest.

\paragraph{}
%TODO intentar ponerlo mejor
La primera part és el que s'anomena $wedgie$, i es defineix de forma recursiva. Pels triangles que són fulles de l'arbre, el wedgie és el valor absolut de la diferència entre el punt que hauria d'ocupar en la realitat el punt mig de la base del triangle i el punt que està ocupant en la representació. És a dir, el valor absolut de la resta del valor que obtenim de demanar-li al mapa l'alçada del punt mig de la base del triangle i de la mitja de les alçades dels dos vèrtex extrems de la base. \newline
Per aquells triangles que no són fulla de l'arbre el wedgie del triangle és la suma del càlcul anterior i el màxim dels wedgies dels dos fills del triangle.

\paragraph{}
La segona part de la prioritat del càlcul de la prioritat consisteix en ponderar el wedgie segons la posició de l'observador per tal de poder tenir un algorisme dinàmic. Aquesta ponderació és lògica ja que si pensem en el wedgie com a error que està cometent un triangle, no ens ha d'importar que hi hagi errors grans si aquests estan molt lluny de l'observador, mentre que potser si hauriem d'intentar corregir un error petit si aquest està just al davant de l'observador. La ponderació que es fa servir per calcular el valor final de la prioritat d'un triangle és la projecció del wedgie a espai de pantalla, amb això fem un càlcul proporcional al nombre de píxels d'error que el wedgie realment està causant a la pantalla, i per tant, tenim un càlcul que ens pot servir per ordenar els triangles tenint en compte quin és el que està causant més error a la visualització.

\subsubsection{Construcció de l'arbre de triangles}
\paragraph{}
Hi ha dues formes de construir l'arbre de triangles donat un mapa i una posició de l'observador. La primera reconstrueix l'arbre per a cada nova posició de l'observador, això la fa menys eficient però més fàcil d'entendre, la segona manera reutilitza l'arbre anterior i el transforma en un arbre òptim per la nova posició de l'observador. \newline
La primera forma de construir l'arbre de triangles utilitza aquest algorisme.\newline
\texttt{
Sigui Q una cua de triangles ordenada per prioritat \newline
Afegir els dos triangles base del mapa a Q \newline
Mentre el mapa sigui massa petit fer \{ \newline
\smallskip ~ Obtenir T, el triangle de Q amb més prioritat \newline
\smallskip ~ Partir T \newline
\smallskip ~ Actualitzar Q d'aquesta forma \{\newline
\smallskip ~ ~ Eliminar T i els altres triangles partits de Q \newline
\smallskip ~ ~ Afegir tots els triangles creats per la partició a Q \newline
\smallskip ~ \}\newline
\} \newline
}

D'aquesta manera es garanteix que quan arribem al nombre de triangles al que volem que arribi l'algorisme tindrem l'arbre òptim, ja que hem anat partint sempre els triangles que tenien més prioritat, és a dir, aquells que cometien més error.
\paragraph{}
La segona manera de construir l'arbre de triangles és aquesta:\newline
\texttt{
Sigui Q una cua de triangles ordenada per prioritat \newline
Sigui K una cua de diamants ordenada per prioritat \newline
Si estem al instant inicial\newline
\smallskip ~ Afegir els dos triangles base del mapa a Q \newline
Altrament \newline
\smallskip ~ Actualitzar la prioritat de tots els elements de Q i K donada la nova
\smallskip ~ posició de l'observador \newline
Mentre el mapa sigui massa petit o la prioritat màxima de Q sigui més gran que la mínima de K fer \{ \newline
\smallskip ~ Si el mapa es massa petit \{ \newline
\smallskip ~ ~ Obtenir T, el triangle de Q amb més prioritat \newline
\smallskip ~ ~ Partir T \newline
\smallskip ~ ~ Actualitzar les cues d'aquesta forma \{\newline
\smallskip ~ ~ ~ Eliminar T i els altres triangles partits de Q \newline
\smallskip ~ ~ ~ Afegir tots els triangles creats per la partició a Q \newline
\smallskip ~ ~ ~ Eliminar de K qualsevol diamant del que s'hagin partit els seus fills \newline
\smallskip ~ ~ ~ Afegir a K tots els nous diamants fusionables que s'hagin creat \newline
\smallskip ~ \} Altrament \{ \newline
\smallskip ~ ~ Obtenir D, format per T i T2, el diamant de K amb menys prioritat \newline
\smallskip ~ ~ Fusionar D \newline
\smallskip ~ ~ Actualitzar les cues d'aquesta forma \{\newline
\smallskip ~ ~ ~ Eliminar de Q els fills de T i T2, fusionats al fusionar D \newline
\smallskip ~ ~ ~ Afegir T i T2 a a Q \newline
\smallskip ~ ~ ~ Eliminar D de K \newline
\smallskip ~ ~ ~ Afegir a K tots els nous diamants fusionables que s'hagin creat \newline
\smallskip ~ \}\newline
\} \newline
}

Si ens fixem en el cas de l'instant inicial el codi es comporta de forma idèntica al primer algorisme, ja que el mapa sempre té masses pocs elements i per tant entra al primer cas del $Si$. A la resta de casos es reaprofiten els triangles bons de l'arbre de triangles que s'havia creat per la posició anterior de l'observador, mentre que els aquells triangles que havien estat partits anteriorment, formant diamants fusionables, i que han passat a tenir menys prioritat que triangles que es poden partir es fusionen, així a la propera volta del $Mentre$, hi haurà triangles menys triangles dels necessaris, s'entrarà al primer cas del $Si$ i es partirà el triangle que estigui cometent més error.

\subsubsection{View frustum culling}
\paragraph{}
El view frustum culling no és un requeriment obligatori de l'algorisme ROAM, però si s'implementa milloren els resultats. La implementació del view frustum culling consisteix en calcular per cada triangle si està o no dintre del volum de visualització, és a dir, dintre de tot allò que s'està mostrant per pantalla. Si un triangle no està dintre del volum de visualització se li assigna una prioritat molt petita, ja que encara que s'estigui cometent un gran error en aquell triangle, realment a l'observador no li importa, ja que no està veient aquella zona.

\subsection{El format DEM}
\label{sec:dem}
\paragraph{}
El format DEM (Digital Elevation Model) va ser creat per l'USGS \textit{(United States Geological Survey)} per guardar la informació de les seves mesures de la superfície dels Estats Units.
\paragraph{}
Un fitxer DEM està organitzat en tres tipus de registres lògics: A, B i C. 
\begin{itemize}
\item El tipus de registre A conté informació en quant a les característiques generals del mapa, nom, límits, unitats de mesura, elevació mínima i màxima, el número de registres de tipus B, etc. Només hi ha un registre de tipus A per fitxer.
\item Els registres de tipus B contenen la informació de les alçades propiament dita.
\item El tipus de registre C conté estàdistiques en quant a l'exactitud de les dades del fitxer.
\end{itemize}
\paragraph{}
El format DEM estava pensat per emmagatzemar-se en cintes magnètiques i es per això que l'especificació del format parla de registres físics, cadascun de 1024 bytes. En un registre físic no hi pot haver més d'un registre lògic, en canvi és usual que els registres lògics de tipus B ocupin més d'un registre lògic. Les parts d'un registre físic no ocupades per la informació d'un registre lògic s'han d'omplir amb blancs. Els registres lògics de tipus A i C mai ocupen més d'un registre físic.
\paragraph{}
Els fitxers DEM divideixen el mapa en una graella i proporcionen l'alçada de cadascun dels punts de la graella. Cada registre de tipus B té la informació de les alçades d'una columna d'aquesta graella, es a dir, si la graella d'un mapa tingués n columnes i m files hi hauria n registres de tipus B cadascun amb m alçades.
\paragraph{}
Hi ha tres tipus de fitxers DEM:
\begin{enumerate}
\item \textbf{DEM d'1 grau:} Tenen 1201*1201 punts de dades, estan basats en latitud-longitud i l'espaiat entre els punts de la graella és de 3 segons d'arc, que és aproximadament 90 metres, encara que obviament depèn de la latitud del planeta en que s'hagin pres les mesures.
\item \textbf{DEM de 30 minuts:} Són 4 unitats de fitxers DEM d'1 grau distribuïdes de forma conjunta, són el menys comú dels 3 tipus.
\item \textbf{DEM de 7.5 minuts:} L'espaiat entre els punts de la graella pot ser de 30 o 10 metres (1 segon d'arc i 1/3 de segon d'arc respectivament), els límits del fitxer estan basats en latitud-longitud, però en canvi els punts de dades es donen en coordenada x-y d'una projecció Mercator, resultant en fitxers on no tots registres de tipus B tenen la mateixa longitud. (Figura \ref{fig: dem})
\end{enumerate}

\begin{figure}[h]
\centering
\includegraphics{images/dem75.png}
\caption{Esquema d'un DEM de 7.5 minuts}
\label{fig: dem}
\end{figure}

\subsubsection{Per què el format DEM?}
\paragraph{}
Hi ha molts tipus de format de fitxer diferents que descriuen terrenys. Aquesta secció explica quines són les raons bàsiques que han portat a escollir aquest tipus de format i no un altre.
\begin{itemize}
\item \textbf{Disponibilitat de l'especificació:} Per tal de poder implementar un parser d'un tipus de format de fitxer és molt important que hi hagi disponibilitat de l'especificació, ja que sense especificació s'ha de fer enginyeria inversa sobre el fitxer i això, a part d'estar fora del que es vol fer amb el projecte, hauria allargat de forma considerable el temps de desenvolupament. Per implementar el parser de DEM s'ha fer servir el document sobre DEM que es menciona a la bibliografia.
\item \textbf{Disponibilitat de mapes:} La disponibilitat de mapes és, evidentment, molt important. Sense mapes no val per a res implementar el parser ja que no es pot comprovar que la implementació sigui correcte i, a més a més, no es pot verificar tampoc el funcionament de l'algorisme ROAM funcioni. A la bibliografia es pot trobar una pàgina on hi ha mapes de Hawaii en format DEM.
\end{itemize}

\subsection{El format de mapes simples}
\paragraph{}
El format de mapes simples \textit{(extensió PM)} és un format inventat per mi. El vaig fer servir per poder provar les primeres implementacions de l'algorisme abans d'haver desenvolupat el lector de fitxers DEM. Els mapes simples tenen una sintaxi molt simple, la primera linea conté un nombre $k$ que representa el nombre de files i columnes del mapa (els mapes han de ser quadrats), a partir d'aquí hi ha $k*k$ nombres, que representen les $k$ files del mapa, on cada fila té $k$ elements.

\newpage
\section{Especificació}
\label{sec:especificacio}

\subsection{Què és libroam?}
libroam és la part del projecte que implementa l'algorisme ROAM. Està programada com a llibreria de forma que qualsevol programa pugui usar aquesta funcionalitat. La llibreria està sota llicència GPL (l'annex \ref{sec:gpl} explica que és aquesta llicència). La llibreria funciona fent servir el paradigma de navegació fly. Per veure una descripció dels diferents paradigmes de navegació aplicables als gràfics 3D consulteu l'annex \ref{sec:parnav}

\subsection{Què és r3v?}
r3v és una aplicació que utilitza la llibreria libroam per tal de proporcionar un visor de superfícies que utilitzi l'algorisme ROAM. L'aplicació afegeix sobre la llibreria una interfície gràfica d'usuari basada en la llibreria Qt (A l'annex \ref{sec:qt} trobareu una descripció d'aquesta llibreria) que permet a l'usuari obrir i tancar mapes, així com visualitzar-los i navegar per ells.

\subsection{Requeriments no funcionals}
\label{sec:reqnf}
\paragraph{Definició:} Els requeriments no funcionals (o qualitats del sistema), capturen les propietats requerides pel sistema software, com el rendiment, la seguretat, la mantenibilitat, etc., en altres paraules, com de bé s'ha de complir un aspecte estructural o de comportament del sistema.

\begin{itemize}
\item \textbf{Traduibilitat:} Que la interfície gràfica del programa es pugui traduir a tots els idiomes que es desitgi és un requeriment important, així s'amplia el públic potencial al qual anirà dirigida l'aplicació, ja que no tothom té coneixement d'anglés.
\item \textbf{Portabilitat:} Es vol que tant r3v com libroam es puguin compilar, i per tant, executar a la majoria de sistemes disponibles.
\item \textbf{Independència entre la interfície i l'algorisme:} Es vol que la implementació de la interfície gràfica sigui el més independent possible de l'algorisme ROAM, per tal que si en algun moment es vol fer una interfície gràfica usant un altre toolkit que no sigui Qt es pugui reutilitzar la majoria del codi.
\item \textbf{Usabilitat:} La usabilitat és molt important en tots els projectes de software, ja que a part que un programa sigui potent en el que fa es necessari que sigui fàcil d'usar.
\item \textbf{Mantenibilitat:} Es necessari que el programa es pugui mantenir amb relativa facilitat, ja que normalment el cicle de vida dels projectes de software porta als programadors a revisar/ampliar el codi.
\item \textbf{Programari lliure:} Es vol que l'aplicació sigui programari lliure, en especial, programari lliure sota la llicència GPL.

\end{itemize}

\subsection{Requeriments funcionals}
\paragraph{Definició:} Els requeriments funcionals capturen el comportament que es vol que tingui el sistema software. Aquest comportament es pot expressar com a serveis, tasques o funcions que cal que el sistema sigui capaç de fer.
\begin{itemize}
\item \textbf{Implementar l'algorisme ROAM:} Volem que el projecte implementi l'algorisme ROAM per tal de visualitzar terrenys.
\item \textbf{Navegar pels terrenys:} Es vol que el programa permeti a l'usuari navegar pel terreny. S'ha escollit el paradigma de navegació fly.
\item \textbf{Carregar mapes des de fitxer:} No es vol que el terreny que visualitzi el programa sigui fixe, per tant, s'haurà d'implementar la possibilitat d'obrir nous mapes des de fitxers.
\item \textbf{Intèrpret de fitxers DEM:} El requeriment anterior implica que caldrà saber llegir algun tipus de fitxer que proporcioni les dades de les alçades per crear el mapa, com s'explica a l'apartat \ref{sec:dem} s'ha decidit utilitzar el format DEM.
\end{itemize}

\newpage
\subsection{Model Conceptual}

\paragraph{}
\begin{figure}[h]
\centering
\includegraphics{images/especificacioSimple.png}
\caption{Diagrama de classes del domini}
\label{fig:diagramaClasses}
\end{figure}

\subsubsection{Restriccions d'integritat textuals}
\begin{itemize}
\item Un triangle o bé te dos fills o no en té cap, no pot tenir-ne només un.
%TODO \item ARGGGGGGGGG ERA ALGO CON LOS BUCLES
\end{itemize}

\newpage
\subsubsection{Classe r3vMap}
\begin{figure}[h]
\centering
\includegraphics{images/mapa.png}
\caption{Classe r3vMap}
\end{figure}
\paragraph{Descripció informal:} La classe $r3vMap$ és la classe encarregada d'emmagatzemar la informació dels mapes, per aquest fi té els següents membres i operacions:
\begin{itemize}
\item $heights$: emmagatzema les alçades de tots els punts disponibles al mapa en forma de vector de vectors.
\item $byColumns$: indica si aquest vector de vectors és un vector de files o un vector de columnes. 
\item $minHeight$: indica l'alçada mínima del mapa.
\item $amplitude$: indica la diferència entre alçada màxima i alçada mínima al mapa.
\item $baseDiamond$: retorna el diamant que forma la base del mapa
\item $calcAmplitude$: calcula els valors $minHeight$ i $amplitude$
\item $height$: retorna l'alçada del punt donat
\item $triangles$: retorna el nombre de triangles que hi representant el mapa actualment
\item $leaves$: retorna el nombre de triangles fulla que hi representant el mapa actualment
\item $getNode$: retorna el node que representa el punt donat
\item $size$: retorna la mida del mapa, és a dir, la longitud de cadascun dels vectors de $heights$
\item $color$: retorna el color que ha de representar l'alçada donada
\end{itemize}


\newpage
\subsubsection{Classe diamond}
\begin{figure}[h]
\centering
\includegraphics{images/diamond.png}
\caption{Classe diamond}
\end{figure}
\paragraph{Descripció informal:} La classe $diamond$ representa la unió de dos triangles que comparteixen la seva base en un diamant. S'utilitza per dues funcions: obtenir el diamant base del mapa per tenir així el bosc de triangles que formen el mapa i per mantenir la llista de diamants potencialment fusionables que necessita l'algorisme. Descripció dels membres:
\begin{itemize}
\item $t1$: dóna un dels triangles del diamant.
\item $t2$: dóna l'altre triangle del diamant.
\item $priority$: retorna la prioritat del diamant, que és la màxima de la prioritat dels dos triangles que el formen.
\item $merge$: fusiona el diamant actualitzant les llistes de triangles partibles i diamants fusionables.
\item $clean$: elimina els triangles que formen el diamant, només s'utilitza quan es tanca el mapa.
\end{itemize}


\newpage
\subsubsection{Classe frustum}
\begin{figure}[h]
\centering
\includegraphics{images/frustum.png}
\caption{Classe frustum}
\end{figure}
\paragraph{Descripció informal:} La classe $frustum$ representa el frustum de visualització actual, també emmagatzema la matriu modelViewMatrix, que és necessària per calcular el frustum i també per calcular la prioritat dels triangles. Descripció dels membres:
\begin{itemize}
\item $frustum$: conté els quatre coeficients dels sis plans que formen el frustum de visualització actual.
\item $mvm$: conté els setze valors de la matriu modelViewMatrix.
\item $setTriangleStatus$: estableix l'estat del triangle respecte al frustum. L'estat pot ser completament dintre, completament fora o parcialment dintre del frustum.
\end{itemize}


\newpage
\subsubsection{Classe observer}
\begin{figure}[h]
\centering
\includegraphics{images/observer.png}
\caption{Classe frustum}
\end{figure}
\paragraph{Descripció informal:} La classe $observer$ representa l'observador. Membres:
\begin{itemize}
\item $posX, posY, posZ$: la posició del observador.
\item $rotX, rotY$: la rotació de l'observador respecte els eixos, defineix la direcció de visió.
\item $step$: longitud del pas de l'observador.
\item $fordward$: mou a l'observador un pas endavant en la direcció de visió.
\item $backward$: mou a l'observador un pas enrera en la direcció de visió.
\item $left$: mou a l'observador un pas a l'esquerra respecte la direcció de visió.
\item $right$: mou a l'observador un pas a la dreta respecte la direcció de visió.
\item $rotate$: canvia la rotació de l'observador.
\item $angles$: retorna els angles de rotació actuals.
\item $position$: retorna la posició actual.
\item $setPosition$: estableix la posició de l'observador.
\item $vrp$: retorna el vrp (View Reference Point) de l'observador.
\end{itemize}


\newpage
\subsubsection{Classe node}
\begin{figure}[h]
\centering
\includegraphics{images/node.png}
\caption{Classe node}
\end{figure}
\paragraph{Descripció informal:} La classe $node$ representa un vèrtex d'un triangle. Descripció dels membres:
\begin{itemize}
\item $posX, posY posZ$: posició del vèrtex
\item $getTriangle$: retorna el triangle que comparteixi aquest node i el node donat amb el triangle donat. En cas que n'hi hagi més d'un (n'hi pot haver dos), retorna el de nivell més petit. Aquesta operació es fa servir per obtenir el triangle que comparteix la base d'un triangle; per fer-ho es crida la operació sobre el node esquerre d'un triangle i es passen com a paràmetre el node dret del triangle i el triangle.
\end{itemize}

\newpage
\subsubsection{Classe triangle}
\begin{figure}[h]
\centering
\includegraphics{images/triangle.png}
\caption{Classe triangle}
\end{figure}
\paragraph{Descripció informal:} La classe $triangle$ representa un triangle dintre de la malla de triangles formada per la visualització del mapa. Descripció dels membres:
\begin{itemize}
\item $level$: el nivell del triangle. És el nombre de triangles pare que s'han de recórrer per arribar al diamant base.
\item $ownWedgie$: el wedgie d'aquest triangle.
\item $status$: defineix l'estat del triangle respecte el frustum, pot ser completament fora, completament dintre o parcialment dintre del frustum de visualització.
\item $priority$: la prioritat d'aquest triangle.
\item $isLeaf$: retorna cert si el triangle no té fills.
\item $isVisible$: retorna cert si el és visible, és a dir, esta completa o parcialment dintre del frustum.
\item $apex, leftVertex, rightVertex$: retornen l'àpex, vèrtex esquerre i vèrtex dret del triangle respectivament.
\item $parent$: retorna el triangle pare (en cas que n'hi hagi).
\item $leftTriangle, rightTriangle$: retornen el fill esquerre i dret respectivament (en cas que existeixin).
\item $deleteLeaves$: elimina els triangles fills en cas que n'hi hagi actualitzant la llista de triangles partibles.
\item $calcPriority$: actualitza el camp $priority$ tenint en compte la posició actual de l'observador (matriu de modelViewMatrix proporcionada pel paràmetre $frustum$).
\item $updateMergeable$: actualitza la llista de diamants fusionables. De forma que elimina els diamants que ja no són fusionables perquè s'han partit els seus fills i afegeix els nous diamants fusionables quan els fills dels triangles no tenen més fills.
\item $getBaseTriangle$: retorna el triangle que comparteix la base amb el triangle.
\item $split$: parteix el triangle actualitzant les llistes de triangles partibles i diamants fusionables.
\end{itemize}


\newpage
\subsubsection{Classe ROAM}
\begin{figure}[h]
\centering
\includegraphics{images/ROAM.png}
\caption{Classe ROAM}
\end{figure}
\paragraph{Descripció informal:} La classe $ROAM$ és on troba la implementació de l'algorisme ROAM. Descripció dels membres:
\begin{itemize}
\item $leaves$: nombre de fulles que volem que tingui l'execució de l'algorisme sobre el mapa actual.
\item $open$: obre el mapa que es troba al fitxer donat, en cas que hi hagi algun error retorna un codi d'error explicant la possible causa.
\item $close$: tanca el mapa actual.
\item $hasMap$: retorna si hi ha alguna mapa obert actualment.
\item $paint$: es on es centra tot l'algorisme ROAM. Actualitza les llistes de triangles partibles i diamants fusionables donada la nova posició de l'observador i parteix triangles i fusiona diamants fins obtenir la malla de triangles òptima per aquest posició.
\item $moveObserverForward$: mou l'observador cap endavant
\item $moveObserverBackward$: mou l'observador cap enrera
\item $moveObserverLeft$: mou l'observador cap a l'esquerra
\item $moveObserverRight$: mou l'observador cap a la dreta
\item $moveObserverUp$: mou l'observador cap a dalt
\item $moveObserverDown$: mou l'observador cap a baix
\item $observerPosition$: retorna la posició de l'observador
\item $observerAngles$: retorna els angles que determinen la línia de visió de l'observador
\item $setObserverPosition$: estableix la posició de l'observador
\item $rotateObserver$: rota la línia de visió de l'observador
\item $paintTriangle$: pinta el triangle donat en cas que sigui un triangle fulla, si no ho fa una crida recursiva per pintar els seus dos fills.
\end{itemize}


\newpage
\subsubsection{Classes parser}
\paragraph{}
\begin{figure}[h]
\centering
\includegraphics{images/parsers.png}
\caption{Classes parsers}
\end{figure}
Aquestes classes són les encarregades de interpretar fitxers que representen mapes i retornar la representació en forma de $r3vMap$.
\begin{itemize}
\item \textbf{\textit{r3vParser}} és una classe abstracte que defineix l'operació $parse$ que tots els intèrprets de mapes han d'implementar.
\item \textbf{DEMParser} és una classe que implementa un intèrpret de mapes en format DEM.
\item \textbf{PMParser} és una classe que implementa un intèrpret de mapes en format PM (mapa simple).
\end{itemize}


\newpage
\subsection{Model de casos d'ús}

\subsubsection{Diagrama de casos d'ús}
\paragraph{}
\begin{figure}[h]
\centering
\includegraphics{images/casosUs.png}
\caption{Diagrama de casos d'ús}
\label{fig: casosUs}
\end{figure}

\subsubsection{Cas d'ús obrirMapa}
\textbf{Cas d'ús:} obrirMapa \newline
\textbf{Actors:} Usuari r3v \newline
\textbf{Propòsit:} Obrir un mapa per tal de visualitzar-lo \newline
\textbf{Tipus:} Primari essencial \newline
\textbf{Curs típic d'esdeveniments:} \newline
\begin{tabular}{ll}
\textbf{Accions dels actors} & \textbf{Resposta del sistema} \\
   1. L'usuari prem l'opció d'obrir un mapa &  \\
 & 2. El sistema mostra els fitxers que es \\
 & poden obrir \\
   3. L'usuari selecciona quin és el fitxer &  \\
   que vol obrir &  \\
 & 4. El sistema obre el mapa contingut \\
 & en aquell fitxer i el mostra \\
\end{tabular}

\subsubsection{Cas d'ús navegar}
\textbf{Cas d'ús:} navegar \newline
\textbf{Actors:} Usuari r3v \newline
\textbf{Propòsit:} Navegar per la visualització del mapa \newline
\textbf{Tipus:} Primari essencial \newline
\textbf{Curs típic d'esdeveniments:} \newline
\begin{tabular}{ll}
\textbf{Accions dels actors} & \textbf{Resposta del sistema} \\
   1. L'usuari prem alguna de les tecles &  \\
   que permet navegar per la visualització &  \\
 & 2. El sistema calcula la nova posició \\
 & de l'observador, actualitza la malla de \\
 & de triangles i actualitza la visualització \\
 & mostrada per pantalla \\
\end{tabular}

\subsubsection{Cas d'ús tancarMapa}
\textbf{Cas d'ús:} tancarMapa \newline
\textbf{Actors:} Usuari r3v \newline
\textbf{Propòsit:} Tancar el mapa que s'està visualitzant en aquest moment \newline
\textbf{Tipus:} Primari essencial \newline
\textbf{Curs típic d'esdeveniments:} \newline
\begin{tabular}{ll}
\textbf{Accions dels actors} & \textbf{Resposta del sistema} \\
   1. L'usuari prem l'opció de tancar el mapa \\
 & 2. El sistema tanca el mapa i  \\
 & actualitza la visualització \\
 & de forma que no mostri res \\
\end{tabular}

\subsubsection{Cas d'ús sortir}
\textbf{Cas d'ús:} sortir \newline
\textbf{Actors:} Usuari r3v \newline
\textbf{Propòsit:} Sortir de l'aplicació \newline
\textbf{Tipus:} Primari essencial \newline
\textbf{Curs típic d'esdeveniments:} \newline
\begin{tabular}{ll}
\textbf{Accions dels actors} & \textbf{Resposta del sistema} \\
   1. L'usuari prem l'opció de sortir \\
 & 2. El sistema es tanca a si mateix
\end{tabular}

\newpage
\section{Disseny}

\subsection{Arquitectura en 3 capes}
\paragraph{}
En un sistema software es necessari descomposar les tasques dels sistema en varies capes per tal que cada capa s'ocupi de les tasques que estiguin en un nivell determinat d'abstracció. La separació típica és en tres capes, una que s'ocupi de la visualització (Capa de presentació), una que s'ocupi d'implementar la funcionalitat del sistema (Capa del domini) i una altra que s'ocupi d'interaccionar amb els fitxers (Capa de gestió de dades).
\paragraph{}
La capa de gestió de dades està formada per les classes $r3vParser$, $DEMParser$ i $PMParser$. Aquestes classes son les encarregades d'obrir i interpretar els fitxers que representen mapes de forma que la capa del domini sigui capaç d'entendre les dades que contenen.
\paragraph{}
La capa de domini de dades està formada per tota la resta de classes que apareixen al diagrama de classes del domini (Figura \ref{fig:diagramaClasses}).
\paragraph{}
La capa de representació té una única classe anomenada $glWidget$.

\subsection{Disseny de la capa de presentació}
\paragraph{}
La classe $glWidget$ és la única classe que forma la capa de presentació. Aquesta classe s'encarrega de proporcionar una vista on es pugui pintar el resultat de processar el mapa usant l'algorisme ROAM així com de capturar els esdeveniments de teclat i de ratolí i passar-los a la capa de domini per tal que aquesta faci el processat oportú.
\paragraph{}
El mode de representació utilitzat és una finestra a pantalla completa ja que d'aquesta forma s'obté una superfície de representació del mapa el més gran possible i, a més a més, l'experiència de l'usuari és més immersiva.
\paragraph{}
La interacció de l'usuari amb l'aplicació es fa mitjançant el teclat i el ratolí. El ratolí serveix per canviar la direcció de visió de l'observador i el teclar serveix per moure l'observador.

\subsection{Controlador del sistema}
\paragraph{}
Tot sistema software rep esdeveniments externs per part de l'usuari o per part d'altres sistemes software. Un cop s'intercepten els esdeveniments a la capa de presentació algun objecte del domini ha de ser l'encarregat de processar aquests esdeveniments. Aquests objectes s'anomenen controladors.
\subsubsection{Controlador façana}
\paragraph{}
En aquest projecte s'ha optat per fer servir un controlador del tipus façana, centralitzat a la classe ROAM. L'avantatge d'utilitzar aquest tipus de controlador és que el domini és una caixa negra per la capa de presentació, d'aquesta manera, qualsevol canvi que es faci a la capa del domini, exceptuant la classe ROAM, no representará cap canvi per la capa de presentació, ja que tota interacció entre la capa de presentació i la capa del domini passa a través del controlador. El problema típic d'aquest tipus de controlador és que acostuma a crear classes molt grans, però degut al petit nombre d'esdeveniments que tracta el sistema aquest problema no és important.

\newpage
\subsection{Model Conceptual}
\begin{figure}[h]
\centering
\includegraphics{images/dissenySimple.png}
\caption{Diagrama de classes del domini - Disseny}
\label{fig:diagramaClassesDisseny}
\end{figure}

\paragraph{}
Les úniques diferències que es poden observar entre aquest diagrama i el que podem veure a la Figura \ref{fig:diagramaClasses} són el canvi d'algunes associacions en associacions direccionals i la pèrdua de l'associació entre $r3vMap$ i $node$ que s'ha convertit en un diccionari. Això és degut a que s'ha optat per que ningú excepte $r3vMap$ pugui crear nodes, d'aquesta manera quan un triangle necessita un node per formar-se, crida l'operació $getNode(..)$ sobre $r3vMap$, aquesta operació comprova si ja hi ha aquell node al diccionari de nodes, si el troba el retorna, si no existeix el crea, l'afegeix al diccionari i el retorna. D'aquesta manera és molt més fàcil mantindre quins són els triangles que utilitzen un node donat.
\paragraph{}
S'han creat dues classes auxiliars, $triangleList$ i $diamondList$, que emmagatzemen les relacions entre ROAM i els triangles i els diamants. Aquestes classes no estan al diagrama de classes que es troba a la part superior ja que no són més que la representació en codi de les associacions entre ROAM i triangles i diamants.
\paragraph{}
Hi ha d'altres canvis que no es veuen en aquest diagrama ja que afecten els membres de les classes. Node ha guanyat l'atribut $color$ que guarda el color del node, ja que si no caldria preguntar-li al mapa quin color havia de tenir cada cop que es volgués pintar un node, això seria molt ineficient, per tant al crear-se el node també s'emmagatzema el seu color. Per aquesta mateixa raó l'operació $color(...)$ del mapa ha passat a ser privada, ja que només es crida quan es vol crear un node.
\paragraph{}
També s'han afegit a algunes classes com $triangle$ i $diamant$ un membre del tipus iterador, amb els seus respectius set/get, aquests camps contenen l'iterador de l'objecte dins de les llistes que manté la classe $ROAM$, això és útil ja que d'aquesta manera l'eliminació és molt més ràpida, ja que no cal tornar a buscar a la llista l'element abans d'eliminar-lo.
\paragraph{}
La classe $triangle$ ha guanyat el membre $wedgie$ que és el wedgie real del triangle, això és per eficiència, ja que cada vegada que necessitem el wedgie podríem usar $ownWedgie$ i fer el recorregut pels fills. També hi la nova operació $updateWedgie$ que serveix per notificar a un triangle que ha d'actualitzar la seva variable $wedgie$. $triangle$ també ha guanyat l'operació privada $setMergeable()$ que rep els paràmetres $bool\ mergeable,\ diamondList\ *mergeQueue,\ triangle\ *baseTriangle$ i s'utilitza a $updateMergeableStatus$ per tal de no haver de repetir les tres o quatre mateixes línies de codi a tres llocs diferents de la funció.

%TODO MIRAR SI HAY ALGUNA DIFERENCIA MAS

\newpage
\subsection{Diagrames de seqüència}
\begin{figure}[h]
\centering
\includegraphics{images/diag/triangleCreate.png}
\caption{Diagrama de seqüència - Triangle - Creadora}
\end{figure}

\newpage
\begin{figure}[h]
\centering
\includegraphics{images/diag/updateWedgie.png}
\caption{Diagrama de seqüència - Triangle - updateWedgie}
\end{figure}

\begin{figure}[h]
\centering
\includegraphics{images/diag/calcPriority.png}
\caption{Diagrama de seqüència - Triangle - calcPriority}
\end{figure}

\newpage
\begin{figure}[h]
\centering
\includegraphics{images/diag/merge.png}
\caption{Diagrama de seqüència - Diamond - merge}
\end{figure}

\newpage
\begin{figure}[h]
\centering
\includegraphics{images/diag/deleteLeaves.png}
\caption{Diagrama de seqüència - Triangle - deleteLeaves}
\end{figure}

\newpage
\begin{figure}[h]
\centering
\includegraphics{images/diag/getNode.png}
\caption{Diagrama de seqüència - r3vMap - getNode}
\end{figure}

\newpage
\begin{figure}[h]
\centering
\includegraphics{images/diag/getTriangle.png}
\caption{Diagrama de seqüència - node - getTriangle}
\end{figure}

\newpage
\begin{figure}[h]
\centering
\includegraphics{images/diag/split1.png}
\caption{Diagrama de seqüència - triangle - split}
\end{figure}

\newpage
\begin{figure}[h]
\centering
\includegraphics{images/diag/split2.png}
\caption{Diagrama de seqüència - triangle - split (continuació)}
\end{figure}

\newpage
\begin{figure}[h]
\centering
\includegraphics{images/diag/paint1.png}
\caption{Diagrama de seqüència - ROAM - paint}
\end{figure}

\newpage
\begin{figure}[h]
\centering
\includegraphics{images/diag/paint2.png}
\caption{Diagrama de seqüència - ROAM - paint (continuació)}
\end{figure}

\newpage
\begin{figure}[h]
\centering
\includegraphics{images/diag/paintTriangle1.png}
\caption{Diagrama de seqüència - ROAM - paintTriangle}
\end{figure}

\newpage
\begin{figure}[h]
\centering
\includegraphics{images/diag/paintTriangle2.png}
\caption{Diagrama de seqüència - ROAM - paintTriangle (continuació)}
\end{figure}


%TODO alguna mas???

\newpage
\subsection{Escala de colors}
\paragraph{}
A l'hora de visualitzar el terreny s'ha decidit assignar-li a cada vèrtex un color que tingui a veure amb la seva alçada, d'aquesta manera és més fàcil per l'observador diferenciar les alçades de cada terreny. L'esquema que s'ha utilitzat es bastant simple, el punt més baix és de color blau, segons es va pujant d'alçada es va degradant el color cap al verd, de forma que els punts amb l'alçada mitja tenen color verd, la resta de punts a més alçada tenen un color que es va degradant del verd al vermell, que és el color dels punts més alts del terreny.
\begin{figure}[h]
\centering
\includegraphics{images/cube.png}
\caption{Escala de colors que s'ha utilitzat}
\label{fig: cub}
\end{figure}

\newpage
\section{Implementació}

\subsection{Requeriments no funcionals}
\paragraph{}
En aquest capítol explicarem les decisions d'implementació que s'han pres per garantir els requeriments no funcionals mencionats a l'apartat \ref{sec:reqnf}

\begin{itemize}
\item \textbf{Traduïbilitat:} L'anglés és l'idioma en el qual s'han escrit els textos de la interfície original, ja que com és l'idioma més extés, és més fàcil trobar traductors per a la resta d'idiomes, en canvi si els textos estiguessin originalment en català o castellà la quantitat de traductors es reduiria de forma considerable. Tots els textos de l'aplicació estan a la part de r3v i no a la part de la llibreria libroam, això ha permés utilitzar les facilitats proporcionades per Qt per la traducció de programes. S'han utilitzat els programes lupdate, lrelease i linguist i la funció tr() que marca els textos que han de ser traduïts i els tradueix en cas que existeixi la traducció d'aquesta cadena a l'idioma que s'està utilitzant.
\begin{itemize}
\item lupdate és el programa que s'encarrega de llegir els fitxers del codi font, buscar els textos que han de ser traduïts i actualitzar fitxers .ts que és on els traductors han de fer les traduccions.
\item linguist és el programa que han d'utilitzar els traductors per escriure les traduccions de cada una de les cadenes de text que s'han de traduir.
\item lrelease és el programa que transforma els fitxers .ts en fitxers .qm. Els fitxers .qm són representacions binàries de la traducció que utilitza el programa un cop s'està executant.
\end{itemize}
Cada cop que s'executa el programa r3v en un ordinador es consulta la variable \textit{QLocale::system().name()} que dóna el nom del l'idioma que s'està usant en el sistema operatiu, amb aquest nom es cerquen les traduccions disponibles, si n'hi ha alguna que concorda es fa servir aquesta, si no hi ha traducció a aquest idioma es fan servir els textos en anglès.

\item \textbf{Portabilitat:} Per aconseguir que tant r3v com libroam es puguin compilar, i per tant, executar a la majoria de sistemes disponibles s'ha pres la decisió d'utilitzar C++ i la seva llibreria estàndard per a la programació, ja que C++ és un llenguatge pel qual hi ha compiladors disponibles per la majoria de sistemes operatius. D'igual manera la interfície està feta en Qt, un toolkit en C++ que permet crear interfícies gràfiques d'usuari i té versions per a Linux/Unix, Mac OS i Windows. Finalment hi ha el problema de portabilitat de l'API 3D, això s'ha ressolt utilitzant OpenGL, una API 3D que també té implementacions per a la majoria de sistemes operatius actuals. Per conèixer més a fons que és una API 3D podeu consultar l'annex \ref{sec:api3d}

\item \textbf{Independència entre la interfície i l'algorisme:} Per aconseguir que la implementació de l'algorisme sigui independent de la interfície gràfica, s'ha programat l'algorisme com a una llibreria que utilitza tan sols C++ i les classes que proporciona la llibreria estàndard de C++, d'aquesta manera el canviar de Qt a un altre sistema per crear interfícies gràfiques com Gtk només suposa reescriure la classe que s'ocupa de gestionar els esdeveniments de teclat i ratolí, tota la resta és completament independent.

\item \textbf{Programari lliure:} Per tal de poder garantir que el programa resultant pugui tenir llicència GPL, a part de declarar que el nostre codi és GPL també cal que que totes les llibreries que s'usin siguin GPL. Qt que és l'única llibreria usada també ho es.

\end{itemize}

\subsection{Obtenció d'altures de coordenades no existents}
\paragraph{}
Un dels problemes que s'han hagut de solucionar a l'hora de fer la implementació de l'algorisme és la obtenció de les altures de coordenades no existents al mapa, és a dir coordenades que no tenen una alçada associada al mapa. Això és un problema ja que l'algoritme pot demanar l'altura de qualsevol punt del mapa, mentre que els fitxers només proporcionen altures per un nombre finit de punts. És evident, per tant, que la resta de coordenades ens les hem $d'inventar$. El problema rau en com crear aquestes noves altures, ja que si donem una altura que no es correspon a aquell punt estarem enganyant a l'algorisme i fent que comenci a partir aquella zona quant potser en la realitat no cal.
\paragraph{}
Hi ha moltes maneres d'aproximar alçades per a una coordenada donada sabent l'alçada dels punts del voltant, però moltes d'elles utilitzen costoses funcions matemàtiques que no ens podem permetre implementar en aquest programa, ja que és molt important ser eficient a l'hora de demanar l'alçada d'un punt del mapa. Podem veure una explicació de la solució utilitzada a la figura \ref{fig: puntsNE}, per implementar aquesta solució només calen sumes, restes i alguna multiplicació.

\begin{figure}[h]
\centering
\includegraphics{images/puntsNE.png}
\caption{Obtenció d'altures de coordenades no existents}
\label{fig: puntsNE}
\end{figure}

\paragraph{}
Com es pot veure a la figura s'ha utilitzat una solució que consisteix en utilitzar quatre punts dels que coneixem d'alçada per interpolar l'alçada de cinc punts addicionals, quatre d'ells sobre les línies que uneixen els punts, essent el valor assignat la mitjana de les alçades dels dos punts, i el cinquè, el punt situat en el centre dels quatre punts, essent l'alçada interpolada la mitjana de tots quatre. A partir d'aquí podem veure que ja coneixem uns quatre punts per quatre quadrants més, per tant podem continuar subdividint el mapa fins a obtenir la coordenada que més ens interessi.
\paragraph{}
La solució implementada no és exactament aquesta, ja que aquesta també seria costosa ja que necessitaria molta recursió per segons quins punts, sinó la transformació a fórmula matemàtica de l'esperit d'aquest mètode, per tant amb un sol pas podem obtenir l'alçada interpolada de qualsevol punt.

\subsection{Generació de Makefiles}
\paragraph{}
Qt té la seva pròpia eina per la generació automàtica de Makefiles anomenada Qt, però com ja s'ha comentat no volem dependre de Qt, per tant, hi havia dos opcions, la creació manual dels Makefiles o usar un generador automàtic de Makefiles que sigui \textit{neutre}. La creació manual de Makefiles va quedar descartada ràpidament, ja que era una opció més pesada i menys potent, per tant s'havia de decidir quin generador automàtic usar. Aquesta decisió tampoc va ser gaire complicada, ja que encara que hi ha una varies eines que poden fer aquesta tasca, autotools és la més comú i es pot trobar a quasi totes les distribucions de Linux i a també funciona a quasi tots els Unix.

\subsection{Autotools}
\paragraph{}
Encara que sovint es parla d'Autotools (tal i com es farà en aquest document), Autotools és en realitat un paraula utilitzada per referir-se a un conjunt d'eines el nom de les quals comença per auto-, com autoheader, automake i autoconf. La sintaxi dels fitxers utilitzats per les autotools pot semblar complicada inicialment però si ens limitem a fer coses simples com les que fa aquest projecte (compilar una llibreria i un executable que depèn d'ella) es força potent i fàcil de fer servir.

\paragraph{}
Autoconf és l'eina que serveix per comprovar que la plataforma en la que es compilarà el programa té les eines i llibreries que calen. A part, també serveix per detectar particularitats de la plataforma, per exemple si en aquesta plataforma una funció te uns paràmetres no estàndard, i definir uns símbols que més tard farem servir en el codi font per adaptar-nos a totes les plataformes. Per part del programador només s'ha de crear el fitxer configure.in que conté paraules clau que indiquen totes les comprovacions que volem fer, a partir d'aquest fitxer, autoconf genera un script anomenat configure que en executar-se en l'ordinador que està compilant el programa fa les comprovacions i avisa en cas de que alguna condició no és compleixi.

\paragraph{}
Per aquest projecte el fitxer configure.in es limita a comprovar l'existència d'un compilador de C++, que l'eina libtool es trobi instal·lada al sistema i finalment fa la comprovació de si Qt està instal·lat. En el cas de Qt es comprova si la versió instal·lada és 3.x o 4.0 i es defineix el símbol Qt4 de forma que el programa funcioni tant amb les versions 3.x com amb la versió 4.0 (que com s'ha esmentat anteriorment encara no té versió final, però ja hi ha versions preliminars suficientment funcionals per compilar aquest projecte).

\paragraph{}
Automake és l'eina que serveix per generar els Makefile. De forma ràpida un Makefile és un fitxer que indica com s'ha de compilar un programa i la depèndencia dels fitxers entre si, de forma que en canviar un fitxer es tornin a recompilar només aquells que tenen alguna relació. Aquesta eina genera fitxers Makefile.in a partir de fitxers Makefile.am, els fitxers Makefile.in es converteixen en fitxers Makefile al executar-se el configure creat per Autoconf. Als fitxers Makefile.am només cal indicar quines són les llibreries i els fitxers de codi font que utilitza en nostre programa/libreria i Automake s'encarrega de generar un Makefile complet amb els típics install, clean, uninstall, etc.

\paragraph{}
Per aquest projecte hem utilitzat fitxers Makefile.am per generar la llibreria libroam i per generar l'executable r3v, les opcions usades han estat bastant simples, al fitxer Makefile.am de libroam s'ha indicat que volem que sigui una llibreria estàtica generada per libtool formada per tots els fitxers .cpp del directori i a més a més usant les llibreries GL i GLU. Per a l'executable r3v, s'ha indicat que es volia generar un executable usant el codi de la interfície en Qt i usant la llibreria libtool així com la llibreria Qt.

\paragraph{}
L'ús de les autotools presenta un \textit{petit problema} en quant a la portabilitat del projecte, ja que no hi ha versió nativa de les autotools per a Windows. Això significa que el projecte no pot ser compilat directament sota Windows, cal adaptar-lo a les eines del compilador de C++ que s'usi; un petit problema de portabilitat però que no afecta de cap manera que el codi del programa continuï sent portable.


\subsection{Lector de format DEM}
\paragraph{}
El format DEM dóna moltes més dades de les necessàries per implementar un visualitzador de superfícies, com ara, nom del mapa, descripció sobre el mapa, coordenades a les que es troba el mapa, estadístiques sobre l'exactitud dels valors, etc. Aquestes dades poden ser molt interessants, però no en el nostre context, per tant, s'ha decidit que la implementació del lector de fitxers de format DEM per a crear un objecte de la classe r3vMap, ignori tots aquest valors i es centri en les dades d'altitud.

\newpage
\section{Captures de pantalla}
\begin{figure}[h]
\centering
\includegraphics{images/open.png}
\caption{Pantalla d'obertura d'un mapa}
\end{figure}

\newpage
\begin{figure}[h]
\centering
\includegraphics{images/map.png}
\caption{Vista general d'un mapa}
\end{figure}

\newpage
\begin{figure}[h]
\centering
\includegraphics{images/map1.png}
\caption{Vista detallada del mapa anterior}
\end{figure}

\newpage
\begin{figure}[h]
\centering
\includegraphics{images/map2.png}
\caption{Vista detallada d'un altre mapa}
\end{figure}


\newpage
\section{Recursos i Anàlisi de costos}
\subsection{Recursos utilitzats}
\subsubsection{Recursos humans}
\paragraph{}
Els recursos humans per la realització d'aquest projecte s'han reduït a mi mateix, ja que aquestes són les normes de la realització de projectes a la FIB. En alguns casos això no és totalment òptim, per exemple per la redacció de textos, a una empresa no seria un Enginyer Informàtic qui s'ocuparia, però com s'ha dit el projecte és un treball per una sola persona.
\paragraph{}
En cas de haver de buscar a vàries persones per desenvolupar el projecte hauria estat necessari buscar a un dissenyador amb experiència en el món dels gràfics 3D, un programador amb experiència amb OpenGL, C++ i Qt i un escriptor de documentació.
\paragraph{}
La dedicació en temps ha estat variable al llarg del temps de la realització del projecte (que s'ha fet entre Febrer i Juny de 2005) però es pot situar en torn a una mitja de 20 hores setmanals.
NECESITO SUGERENCIAS DE QUE PONER!!!!!!!
\subsubsection{Recursos tecnològics}
\paragraph{}
En quant als recursos tecnològics utilitzats tenim dues branques que es poden diferenciar fàcilment, els recursos hardware i els software.

\paragraph{}
Els recursos software utilitzats per a la realització del projecte han estat tots programes lliures, en especial tots ells part de la distribució Suse Linux 9.1 (utilitzada a la FIB) o de la distribució Mandriva 2005 (utilitzada a casa). Els programes essencials per a la realització d'aquest projecte han estat:
\begin{itemize}
\item \textbf{\textit{gcc:}} Compilador utilitzat, concretament g++, el compilador de C++ del programari gcc
\item \textbf{\textit{kate:}} Editor de text
\item \textbf{\textit{latex:}} Sistema de creació de documents
\item \textbf{\textit{kile:}} Editor de text especialitzat en latex
\item \textbf{\textit{gimp:}} Editor d'imatges utilitzat per la creació d'alguns gràfics explicatius
\item \textbf{\textit{umbrello:}} Programa CASE\footnote{Computer-aided software engineering} utilitzat per fer els diagrames de classes i diagrames de seqüència
\end{itemize}
%TODO QUITAME
ALGUNA IDEA DE QUE MÁS PONER????

\paragraph{}
Els recursos hardware utilitzats es poden resumir en:
\begin{itemize}
\item PCs de desenvolupament: Evidentment tenir ordinadors on poder desenvolupar i provar el codi és molt important, en aquest cas se n'han fet servir dos de diferents. Un a la FIB i un altre a casa. En tots els casos és important poder disposar de diferents màquines on fer les proves per veure que el funcionament és correcte a totes elles, però en el cas d'una aplicació 3D es una mica més important, ja a vegades que el comportament de les targetes 3D amb les mateixes comandes OpengGL varia de xip a xip, i per tant quantes més targetes es provin milor. El PC de la FIB té les següents característiques
\begin{itemize}
\item Processador: Intel Pentium 4 3.00GHz
\item Memòria: 512 MB
\item Disc Dur: 20 GB
\item Targeta gràfica: Ati Radeon 9200
\end{itemize}
mentre que el PC de casa té aquestes
\begin{itemize}
\item Processador: AMD Athlon XP 1600+
\item Memòria: 384 MB
\item Disc Dur: 160 GB
\item Targeta gràfica: PowerVR Kyro 2
\end{itemize}
Cal notar que a la FIB el disc dur utilitzat és un disc dur extraïble de forma que es pot utilitzar a qualsevol dels PCs disponibles de la sala de projectistes.

\item Connexió a la xarxa: En el món de la programació actual tenir connexió a internet és molt important ja que és una font de consulta de manuals molt important. A la FIB s'ha utilitzat la connexió LAN de la facultat mentre que ha casa s'ha fet servir una connexió via mòdem 56K.
\end{itemize}
\subsubsection{Recursos físics}
\paragraph{}
Una part que normalment s'oblida al fer aquest tipus de resum dels recursos utilitzats per fer la realització d'un projecte són els recursos físics, es a dir cadires, taules, edificis, etc. Tot això és completament necessari per poder dur a terme qualsevol projecte, i, de vegades pot ser un cost bastant important, com per exemple en el cas del lloguer o compra d'una oficina. En el cas del projecte que ens ocupa no s'ha hagut d'adquirir cap dels recursos físics utilitzats ja que la Facultat ja proporciona lloc on desenvolupar el PFC.

\newpage
\subsection{Anàlisi de costos}
\paragraph{}
En aquesta taula podem trobar el tipus de personal que cal per realitzar cadascuna de les tasques de les que s'ha composat la realització del projecte això com el temps que s'ha trigat en fer cadascuna d'elles.
\begin{center}
\begin{tabular}{|l|l|l|} \hline
\textbf{Tasca} & \textbf{Tipus}  & \textbf{Hores de realització} \\ \hline
Planificació inicial del projecte & Analista & 15 hores \\ \hline
Especificació & Analista & 75 hores \\ \hline
Disseny & Analista & 75 hores \\ \hline
Implementació & Programador & 125 hores\\ \hline
Realització de proves & Provador de software & 25 hores\\ \hline
Redacció de la memòria & Documentador & 100 hores \\ \hline
\end{tabular}
\end{center}

\paragraph{}
Cada un dels tipus de personal té un sou diferent degut a que els coneixements no són els mateixos. A la taula següent hi figura el cost hora que tindria cada tipus de perfil realitzat.
\begin{center}
\begin{tabular}{|l|l|} \hline
\textbf{Tipus de personal} & \textbf{Cost} \\ \hline
Analista & \EUR{40}/hora \\ \hline
Programador & \EUR{30}/hora \\ \hline
Provador & \EUR{25}/hora \\ \hline
Escriptor de documentació & \EUR{35}/hora \\ \hline
\end{tabular}
\end{center}

\paragraph{}
Això ens dona un cost total per pagar al personal de:
\begin{center}
\begin{tabular}{|l|l|} \hline
\textbf{Tasca} & \textbf{Cost} \\ \hline
Planificació inicial del projecte & 15 * 40 = \EUR{600} \\ \hline
Especificació & 75 * 40 = \EUR{3000}\\ \hline
Disseny & 75 * 40 = \EUR{3000}\\ \hline
Implementació & 125 * 30 = \EUR{3750}\\ \hline
Realització de proves & 25 * 25 = \EUR{625}\\ \hline
Redacció de la memòria & 100 * 35 = \EUR{3500}\\ \hline
\textbf{Total} & \textbf{\EUR{14475}} \\ \hline
\end{tabular}
\end{center}

\paragraph{}
A aquests \EUR{14475} caldria sumar el cost dels recursos hardware, software i físics, però això es complicat de comptar, ja que en el cas de hardware i software el material necessari per la realització del projecte no seria exclusiu per aquest projecte en cas que es tractés d'una empresa, per tant no seria lògic assignar el cost total del material al cost d'aquest projecte. També es pot dir el mateix del cost dels recursos físics, ja que no es pot assignar completament el cost del lloguer d'oficines, mobiliari, etc. que seria necessari per dur a terme la realització del projecte. Per tant, fent una aproximació dels costos d'amortització que es podrien assignar a cadascun dels recursos anteriors es podria xifrar en torn dels  \EUR{20000} el cost total de la realització del projecte.

\newpage
\section{Conclusions i Treball futur}
\paragraph{}
El resultat de la realització d'aquest projecte final de carrera ha estat bastant satisfactori en termes d'objectius assolits, tant en la part requeriments que es volia que complís l'aplicació com en la part de formació final de l'alumne.
\paragraph{}
En quant al compliment de requeriments funcionals i no funcionals que es van establir en la reunió inicial que vam tenir el projectista i el director, es pot dir que s'han assolit totalment, ja que no hi ha cap requeriment dels que vam parlar inicialment que no hagi acabat estant present a l'aplicació final.
\paragraph{}
La part de formació final de l'alumne que se li suposa a la realització d'un projecte d'aquesta envergadura també ha estat profitosa ja que he adquirit més coneixements sobre OpenGL i C++ en general dels que ja tenia, així com també m'he enfrontat a tasca de gestionar un projecte tan llarg per primera vegada, aprenent així totes les coses que això implica, com gestionar el temps d'una manera eficient.
\paragraph{}
Encara que s'hagin complit tots els requeriments que es van parlar en la reunió inicial per definir aquest projecte això no vol dir que no hi hagi coses a millorar o ampliar per tal que libroam o r3v siguin millors. Aquesta és una llista de les varies tasques que es poden afrontar com a treball futur:
\begin{itemize}
\item Organitzar els triangles en strips: Organitzar els triangles en strips no es una tasca senzilla, però fer-ho pot reportar guanys de rendiment, ja que al utilitzar strips de triangles el nombre de vèrtexs que s'envien a pintar es redueix considerablement, i a més a més, algunes targetes gràfiques tenen optimitzacions especials per gestionar els strips de triangles.
\item Càlcul de prioritat diferida: L'observador, normalment, no es mou bruscament de lloc ni gira exageradament, per tant, realment no caldria recalcular la prioritat de tota la llista de diamants i triangles per cada nova posició de l'observador, ja que aquesta prioritat tampoc variarà de forma exagerada, per tant, recalcular només un tant per cent donat dels elements d'aquestes llistes pot ajudar a optimitzar l'algorisme, evidentment s'haurien de programar comprovacions que asseguressin que l'observador no s'ha mogut exageradament, ja que en aquest cas si seria necessari recalcular tota la llista de prioritats.
\item Aturada del càlcul de prioritat per temps: Una altre optimització que es pot afegir a l'algorisme ROAM és donar un límit de temps que volem que es trigui en obtenir la malla de triangles per la nova posició. Això es pot implementar fàcilment, ja que només cal posar la comprovació de temps al $while$ que va regenerant l'arbre de triangle fent les fusions i particions. El fet d'aturar la regeneració de l'arbre de triangles suposarà que no tindrem la malla òptima per la posició, però el que si serà és la millor malla possible en el temps donat, ja que la regeneració es va fent fusionant els pitjors diamants i partint els millors triangles. Aquesta optimització encara que simple de fer no s'ha implementat ja als ordinadors disponibles a l'actualitat la part de regeneració de la malla de triangles no és costosa, sent el pintat per pantalla dels triangles la part que triga més temps.
\end{itemize}


\newpage
\section{Bibliografia}
\paragraph{}
\begin{itemize}
\item Paper sobre l'algorisme ROAM \newline \textit{http://www.llnl.gov/graphics/ROAM/roam.pdf}
\item Especificació del format DEM \newline \textit{http://rockyweb.cr.usgs.gov/nmpstds/acrodocs/dem/2DEM0198.PDF}
\item Documentació de Qt \newline \textit{http://doc.trolltech.com/3.3}
\item Documentació de libstdc++ \newline \textit{http://gcc.gnu.org/onlinedocs/libstdc++/documentation.html}
\item Documentació de la STL de SGI \newline \textit{http://www.sgi.com/tech/stl/table\_of\_contents.html}
\item Document en quant a view frustum culling \newline \textit{http://www.racer.nl/reference/vfc.htm}
\item Document en quant a view frustum culling \newline \textit{http://www.sjbaker.org/steve/omniv/frustcull.html}
\item Mapes de Hawaii en format DEM \newline \textit{http://duff.geology.washington.edu/data/raster/tenmeter/hawaii/}
\end{itemize}
\newpage
\section{Índex de figures}
\listoffigures
\newpage
\section{Annex}

\subsection{Gràfics per computador}
\paragraph{}
Els gràfics per computador és un camp de la computació en el qual s'utilitzen els ordinadors per generar imatges, ja siguin completament sintètiques o generades a partir d'informació obtinguda del món real.

\paragraph{}
Els gràfics per computador tenen dos grans camps, els gràfics 2D i els gràfics 3D.


\subsubsection{Gràfics 2D}
\paragraph{}
Els gràfics 2D són aquells que representen imatges bidimensionals en pantalla. Hi ha dos tipus bàsics d'imatges 2D, els mapes de bits i les imatges vectorials.

\paragraph{}
Els mapes de bits són bàsicament una graella de píxels bidimensional. Cada píxel té una posició assignada dintre de la graella i emmagatzema el seu color. Un mapa de bits te una resolució finita determinada pel nombre de columnes i files, i per tant si es vol fer mostrar més gran del que realment és, sol aparèixer l'efecte de pixelació consistent en que l'observador de la imatge és capaç de distingir cada un dels píxels de forma separada, cosa que no passa quan la imatge es visualitza amb la seva mida real.

\paragraph{}
Les imatges vectorials tenen les dades geomètriques de forma precisa. Els punts es donen en un sistema de coordenades, les dades de la imatge vectorial també contenen la descripció de les connexions entre els punts(per formar línies o rutes), el color de cada punt o línia, el gruix de cara línia o secció, etc. La majoria de sistemes gràfics vectorials també tenen primitives pels tipus de formes més bàsics con els cercles o rectangles. Aquestes dades permeten generar la imatge des de zero. El fet que la imatge estigui guardada amb una descripció de com s'ha de \textit{crear}, permet que les imatges vectorials no sofreixin mai de l'efecte de pixelació encara que també les fa més lentes de visualitzar. Per visualitzar una imatge vectorial s'ha d'acabar creant un mapa de bits.


\subsubsection{Gràfics 3D}
\paragraph{}
Els gràfics 3D tenen dos branques bastant diferenciades, els gràfics 3D per ser visualitzats en una pantalla (ja sigui d'ordinador, televisió, etc.) i els gràfics tridimensionals que es representen de forma volumètrica usant diferents aparells. En aquest document ens centrarem en explicar els gràfics 3D per ser visualitzats en pantalla ja que els altres estan menys desenvolupats i a més a més no tenen cap relació amb l'objectiu del projecte.

\paragraph{}
Els gràfics 3D es diferencien dels gràfics 2D principalment pel fet que en els gràfics 3D hi ha una representació virtual tridimensional dels objectes de l'escena que s'utilitza per fer els càlculs i per obtenir la imatge 2D que finalment s'acabarà representant en pantalla mentre que en els gràfics 2D o bé no hi ha objectes (mapa de bits) o els objectes són bidimensionals (imatges vectorials). En general, els gràfics 3D es poden comparar amb una fotografia d'una escultura, mentre que els gràfics 2D es correspondrien amb un dibuix.

\subsubsection{Gràfics interactius vs Gràfics realistes}
\label{sec:intvsreal}
\paragraph{}
Dins dels gràfics generats per computador (ja siguin 2D o 3D) hi ha dos grans branques. Els gràfics interactius i els gràfics realistes.

\paragraph{}
Els gràfics interactius són aquells en els que l'observador pot influir en la generació dels gràfics. És a dir, l'usuari del programa pot rotar, moure, escalar, etc. els objectes de l'escena a voluntat. Això és útil per a jocs, simuladors i visualitzadors de dades en general. La característica principal que es demana a aquests gràfics és la velocitat de generació, que ha d'estar al voltant de les 25 actualitzacions per segons, de forma que l'observador vegi una suavitat en el moviment, per sota de les 15 actualitzacions per segon el moviment comença a semblar que vagi a salts. Per aquesta raó també se'ls sol anomenar gràfics en temps real. Degut a que la velocitat és el principal factor en aquests tipus de gràfics la qualitat no és molt gran, encara que gràcies a que les targetes acceleradores estan evolucionant molt ràpid, la qualitat ha pujat molt en poc temps. La base d'aquest tipus dels gràfics en el món 3D són els triangles, tot es genera a partir d'una acumulació de triangles, fins i tot les cercles.

\paragraph{}
Els gràfics realistes són aquells on el que prima és que la imatge generada s'asembli el més possible a una imatge real. El destí principal d'aquest tipus de gràfics són les pel·lícules, anuncis, etc. que gràcies als gràfics realistes poden incloure imatges que abans serien o molt cares de fer o, fins i tot, impossibles de rodar. Aquest fet condiciona la velocitat de generació de les imatges i de vegades es triga hores en aconseguir una sola imatge estàtica, per tant, aquest mètode encara que aconsegueix imatges d'una qualitat espectacular no serveix per fer gràfics interactius. A la generació de gràfics 3D s'usen mètodes que utilitzen fórmules matemàtiques que intenten modelar el comportament real de la llum.



\subsection{API 3D}
\label{sec:api3d}
\paragraph{}
Una API (\textbf{A}pplication \textbf{p}rogramming \textbf{i}nterface) és un conjunt de definicions com un component de software interactua amb un altre. És un mètode per aconseguir abstracció entre capes diferents de software, ja sigui entre capes de diferents nivells com de capes del mateix nivell que es dediquen a tasques diferents.

\paragraph{}
Una API 3D és una API que defineix les funcions necessàries per crear gràfics tridimensionals. Avui en dia hi ha dos APIs 3D dominants per la generació de gràfics interactius, OpenGL i Direct3D. Totes les APIs 3D per generar gràfics interactius serveixen també per generar gràfics 2D interactius ja que només cal fer que tots els objectes 3D es situïn en un mateix pla per fer que el mon 3D sigui bidimensional.

\subsubsection{OpenGL}
\paragraph{}
OpenGL (\textbf{Open} \textbf{G}raphics \textbf{L}ibrary) és una especificació d'una API d'un llenguatge per escriure aplicacions que produeixen gràfics 3D. OpenGL és un estàndard definit per la \textit{OpenGL Architecture Review Board}, formada per molt membres de la indústria dels computadors, ja siguin constructors d'ordinadors, de sistemes operatius o de hardware gràfic. Alguns dels membres són Apple, ATI Technologies, Dell, Hewlett-Packard, IBM, Intel, Nvidia, SGI, etc. cosa que converteix OpenGL en un estàndard realment neutral i amb suport per la gran majoria de les plataformes gràfiques.

\paragraph{}
OpenGL va ser introduït el 1992 com a evolució de la interfície 3D IRIS GL de SGI. Un dels problemes de IRIS GL era que tot el que implementava la llibrera havia d'estar suportat pel hardware i per tant si el hardware que no suportava una característica que es feia servir al programa, aquest no es podia executar. OpenGL va solucionar aquest problema proporcionant suport software per a les característiques que el hardware no tenia, cosa que en aquell moment va permetre executar programes 3D en sistemes no tan cars com els que fabricava SGI.

\paragraph{}
Les característiques bàsiques d'OpenGL són:
\begin{itemize}
\item \textbf{Multillenguatge:} Hi ha llibreries que permeten utilitzar OpenGL des de C, C++, Fortran, Ada, Java, Perl, Python, Visual Basic, etc. Per tant, es pot reutilitzar el codi OpenGL d'una aplicació en un llenguatge per programar la mateixa aplicació o similar en un llenguatge diferent.
\item \textbf{Multiplataforma:} OpenGL està disponible per a Windows, Mac OS, Unix comercials, Linux i d'altres sistemes operatius menors, per tant una aplicació que utilitzi OpenGL no està limitada a executar-se en un sistema operatiu en particular.
\item \textbf{Estable:} L'API d'OpenGL s'ha mantingut bastant estable durant més de 7 anys. Això permet que els programes continuïn funcionant sense problemes amb noves versions i a més a més facilita la feina dels programadors que no han d'anar modificant els seus coneixements cada poc temps.
\end{itemize}

\subsubsection{Direct3D}
\paragraph{}
Direct3D és la part que s'encarrega de la visualització tridimensional de l'API DirectX de Microsoft. Només hi ha versions de DirectX (i per tant de Direct3D) per als sistemes operatius de Microsoft (Windows 95 en endavant) encara que la consola XBox (produïda per Microsoft) té una API molt similar a la de DirectX.
\paragraph{}
Hi ha moltes versions de DirectX, cadascuna afegeix noves característiques sobre l'anterior. Això és útil en un món que es mou tan ràpidament com els dels gràfics per computador però també suposa que els programadors han d'anar readaptant el seu coneixement sobre la llibreria per poder programar per les últimes versions.

\subsubsection{Primitives gràfiques 3D}
La majoria d'API per la generació de gràfics 3D interactius tenen un conjunt similar de primitives, és a dir, \textit{d'objectes} que podem fer servir per construir una escena. En aquesta secció ens centrarem en les primitives que té OpenGL.

\begin{itemize}
\item \textbf{GL\_POINTS} - Cada punt que es dona es converteix en un punt a l'espai.
\item \textbf{GL\_LINES} - Cada dos punts que es donen es converteixen en una línia.
\item \textbf{GL\_LINE\_STRIP} - Donats $i$ punts, es creen $i-1$ línies. Els punts que uneix una línia amb índex $k$ són els $k$ i $k+1$.
\item \textbf{GL\_LINE\_LOOP} - Donats $i$ punts, es creen $i$ línies. Els punts que uneix una línia amb índex $k$ són els $k$ i $k+1$ per $0<k<i-1$ i els $i$ i el $0$ per l'última línia ($k = i$).
\item \textbf{GL\_TRIANGLES} - Cada 3 punts que es donen es converteixen en un triangle.
\item \textbf{GL\_TRIANGLE\_STRIP} - Donats $i$ punts, ($i>3$) es creen $i-2$ triangles. El triangle amb índex $k$ està format pels punts amb índex $k$, $k+1$ i $k+2$.
\item \textbf{GL\_TRIANGLE\_FAN} - Donats $i$ punts, ($i>=3$) es creen $i-2$ triangles. El triangle amb índex $k$ està format pels punts amb índex $0$, $k+1$ i $k+2$.
\item \textbf{GL\_QUADS} - Cada 4 punts que es donen es converteixen en un quadrilàter.
\item \textbf{GL\_QUAD\_STRIP} - Els quatre primers vèrtexs formen un quadrilàter. Cada parell successiu de vèrtexs es combina amb el parell anterior per formar un altre quadrilateral.
\item \textbf{GL\_POLYGON} - Té el mateix comportament que \textbf{GL\_LINE\_LOOP}, però en comptes de crear línies crear un polígon.
\end{itemize}
Podem veure exemples de les 10 primitives a la figura \ref{fig: primitives}

\begin{figure}[h]
\centering
\includegraphics{images/primitives.png}
\caption{Primitives gràfiques d'OpenGL}
\label{fig: primitives}
\end{figure}


\subsection{Paradigmes de navegació 3D}
\label{sec:parnav}
\paragraph{}
La navegació d'escenes 3D té tres paradigmes fonamentals, Walk, Fly i Examine. Tota aplicació 3D implementa un d'aquests paradigmes, encara que no n'ha d'implementar només un.

\subsubsection{Paradigma walk}
Al paradigma walk, l'usuari del programa pot moure la càmera i per tant navegar per l'escena. L'usuari sol estar representat per una entitat dins de l'escena anomenada avatar. L'avatar està sotmés a la gravetat i per tant només pot caminar per terrenys plans, pujar pendents poc pronunciades i xoca contra les parets. Els moviments típics de l'avatar són desplaçar-se en qualsevol de les quatre direccions (endavant, endarrera, esquerra i dreta) i gir de la càmera per enfocar cap a qualsevol direcció possible. En aquest paradigma la visió pot ser en primera persona o en tercera persona. A la visió primera persona, la càmera es situa als ulls de l'avatar, veient-se allò que veuria l'avatar, per tant, de l'avatar només es sol veure les mans i peus. A la visió en tercera persona la càmera es situa fora de l'avatar, normalment per darrera d'ell, de forma que ens permet veure la situació de l'avatar d'una manera més global. Aquesta càmera té més problemes de gestió, ja que s'ha d'anar amb compte de que la càmera no atravesi parets quan l'avatar s'apropa a elles, ja que si ho fes no veuriem l'avatar, sinó la paret. A més a més la visió en primera persona sol donar més sensació d'inmersió, per tant la majoria de programes 3D que utilitzen el paradigma walk solen optar per ella.

\subsubsection{Paradigma fly}
El paradigma fly és gairebé igual al paradigma walk, sent la no existència de la gravetat la diferència més gran. El paradigma fly se sol utilitzar en simuladors espaials o bé en els mateixos escenaris que utilitzen el paradigma walk per donar-li a l'usuari més llibertat a l'hora de reconèixer l'escena, per exemple es molt possible que als dissenyadors de pantalles els interessi poder volar per l'escenari per així poder desplaçar-se entre diferents alçades de forma més ràpida. Així mateix a vegades el paradigma fly desactiva la detecció de col·lisions permetent que l'avatar atravesi les parets.

\subsubsection{Paradigma examine}
Al paradigma examine l'observador no es mou, sempre està a la mateixa posició i mira en la mateixa direcció. La interactivitat d'aquest paradigma es a la part dels objectes i no a la de l'observador. Normalment hi ha uns quants objectes (de vegades només un) al punt on està enfocant la càmera i l'usuari put rotar, escalar, desplaçar els objectes de forma que pugui examinar l'objecte completament. Aquest paradigma es sol usar en aplicacions que permeten la visualització d'ossos, peces de maquinària, etc.


\newpage
\subsection{Arbres binaris de triangles}
\label{sec:abt}
\paragraph{}
Un arbre binari de triangles és un arbre que serveix per organitzar triangles de forma jeràrquica. El triangle arrel $T = (v_a, v_0, v_1)$ és un triangle isòsceles amb àpex $v_a$. Els fills de l'arrel es defineixen partint l'arrel en dos parts fent creant una nova aresta que va des del vèrtex $v_a$ al punt mig $v_c$ de l'aresta base (aresta entre $v_0$ i $v_1$). El fill esquerre de $T$ és $T_0 = (v_c, v_a, v_0)$ mentre que el fill dret és $T_1 = (v_c, v_1, v_a)$. La resta de de l'estructura de l'arbre de triangles és una repetició recursiva del procés de partició explicat anteriorment. Dins de l'arbre cada triangle té un nivell $l$ definit pel nombre de vegades que s'ha partit al triangle arrel per arribar a generar aquell triangle en concret. A la figura \ref{fig: triangles} podem veure una representació dels nivells 0 a 5 d'un arbre binari de triangles.

\begin{figure}[h]
\centering
\includegraphics{images/triangles.png}
\caption{Representació dels nivells 0 a 5 d'un arbre binari de triangles}
\label{fig: triangles}
\end{figure}

\subsubsection{Representació de superfícies amb arbres binaris}
\paragraph{}
Per representar una superfície amb arbres binaris de triangles es fan servir dos arbres de triangles situats de forma que comparteixin la seva aresta base, d'aquesta forma es cobreix una superfície quadrada (Figura \ref{fig: diamant}). Un cop tenim una estructura que permet cobrir tot un quadrat només cal assignar a cada vèrtex una alçada $w(v)$ per tenir una forma eficient de guardar les alçades d'un terreny.

\begin{figure}[h]
\centering
\includegraphics{images/diamant.png}
\caption{Dos arbres de triangles serveixen per representar una superfície quadrada}
\label{fig: diamant}
\end{figure}

\subsubsection{Conjunts d'arbres binaris de triangles}
\paragraph{}
Una a triangulació d'arbres binaris de triangles (triangulació d'ara en endavant) és un conjunt d'arbres binaris que tenen alguna relació de veïnatge entre ells, ja sigui compartint un vèrtex o una aresta. Un cas especial de triangulació és el diamant, triangulació format per dos triangles que comparteixen l'aresta base i tenen el mateix nivell, la figura \ref{fig: diamant} és un exemple de diamant. Un fet important d'una triangulació és que donat un triangle, el triangle amb el que comparteix la base és del mateix nivell o del nivell superior. A la figura \ref{fig: triangleBase} podem veure un exemple de les dues situacions, el triangle A comparteix la base amb un triangle del seu nivell mentre que el triangle B comparteix la base amb un triangle d'un nivell superior ($l$ més petita).

\begin{figure}[h]
\centering
\includegraphics{images/triangleBase.png}
\caption{Possibilitats de compartir la base}
\label{fig: triangleBase}
\end{figure}

\subsubsection{Operacions sobre diamants}
\paragraph{}
Sobre un diamant es poden realitzar dues operacions, split i merge. Split (partir) consisteix en crear els fills de $T$ i del seu triangle base $T_B$ de forma que s'obté una triangulació formada pels triangles $T_1$, $T_2$, $T_B1$ i $T_B2$. Merge (fusionar) consisteix en tornar als triangles $T$ i $T_B$ a partir dels seus quatre fills. Es pot veure una representació dels processos de partició i unió a la figura \ref{fig: splitMerge}.

\begin{figure}[h]
\centering
\includegraphics{images/splitMerge.png}
\caption{Split i merge sobre una triangulació}
\label{fig: splitMerge}
\end{figure}

\paragraph{}
Només els triangles que tenen el mateix nivell que el triangle amb el que comparteixen la base són susceptibles de ser partits. Aquells que comparteixen la base amb un triangle de nivell superior ($l$ més petita) (per exemple el triangle B de la figura \ref{fig: triangleBase})  no poden ser partits directament i si realment volem partir-los hem de fer abans un split del triangle amb el que comparteix la base. La figura \ref{fig: forceSplitExtrem} és un cas extrem en el que caldria fer 4 splits forçats abans de fer la partició del triangle $T$.

\begin{figure}[h]
\centering
\includegraphics{images/forceSplitExtrem.png}
\caption{Cas extrem en el que cal aplicar 4 particions forçades}
\label{fig: forceSplitExtrem}
\end{figure}

\paragraph{}
En primera instància es pot pensar que no seria necessari que l'operació de split s'apliquès sobre un diamant i que es podria fer sobre un triangle sol, però això no es possible ja que crearia una discontinuïtat en la superfície. A la figura \ref{fig: discontinuitat} veiem la representació resultant de partir només un dels triangles del diamant d'una superfície en la que els punts $(0, 0)$, $(0, 1)$, $(1, 0)$ i $(1, 1)$ tenen una alçada de 0 mentre que el punt $(0.5, 0.5)$ té una alçada de 1.

\begin{figure}[h]
\centering
\includegraphics{images/discontinuitat.png}
\caption{Discontinuïtat: Resultat de partir un triangle i no un diamant}
\label{fig: discontinuitat}
\end{figure}


\newpage
\subsection{GPL}
\label{sec:gpl}
\paragraph{}
GPL (\textbf{G}eneral \textbf{P}ublic \textbf{L}icense) és una llicència de software lliure. La llicència GPL garanteix als destinataris d'un programa informàtic els següents drets o llibertats:
\begin{itemize}
\item La llibertat per executar el programa sigui quin sigui el propòsit
\item La llibertat d'estudiar com funciona el programa i de modificar-lo (Evidentment cal tenir accés al codi com a precondició per complir això)
\item La llibertat de distribuir copies (ja siguin modificades o sense modificar)
\end{itemize}
\paragraph{}
La llicència GPL és una de les llicències de software lliure més esteses, si visitem la pàgina de SourceForge (una pàgina web on es registren projectes de software lliure per tal de desenvolupar-los usant les serveis que aquesta proporciona) que llista el número de projectes registrats per cada tipus de llicència, veiem que un 69\% (43089 dels 62291) utilitzen la llicència GPL.
\paragraph{}
El text complet de la llicència es troba a \textit{http://www.gnu.org/licenses/gpl.html}


\subsection{Qt}
\label{sec:qt}
\paragraph{}
Qt és un \textit{framework} complet de desenvolupament d'aplicacions en C++. Inclou una llibreria així com eines per la internacionalització i el desenvolupament multiplataforma d'aplicacions.
\paragraph{}
Qt aconsegueix ser multiplataforma abstraient els sistemes operatius i de gestió de finestres, de forma que proporciona una API coherent, lògica i orientada a objectes comú. Les aplicacions Qt s'executen nativament, compilades des del mateix codi font, a totes les plataformes suportades:
\begin{itemize}
\item Qt/Windows (Microsoft Windows XP, 2000, NT 4, Me/98/95)
\item Qt/X11 (Linux, Solaris, HP-UX, IRIX, AIX, i altres variants Unix)
\item Qt/Mac (Mac OS X)
\item Qt/Embedded (Linux embedded)
\end{itemize}
\paragraph{}
La llibreria inclou una gran part de classes per a la construcció d'interfícies gràfiques, encara que també proporciona moltes altres funcionalitats, com comunicació per xarxa via sockets, classes per treballar amb XML, classes per accedir a fitxers, etc.
\paragraph{}
Qt té un sistema de llicències dual que permet desenvolupar tant aplicacions lliures (sota la llicència GPL) com aplicacions propietàries. Per poder desenvolupar aplicacions propietàries s'ha de pagar una llicència de Qt per cada programador. Actualment, aquest sistema està disponible per totes les plataformes excepte per a Qt/Windows on només hi ha la possibilitat de pagar per una llicència, però la versió Qt 4.0, esperada per finals del segon quadrimestre del 2005, també usarà aquest sistema per Qt/Windows.


\end{document}
