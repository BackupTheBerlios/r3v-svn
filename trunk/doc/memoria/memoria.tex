\documentclass[a4paper,12pt]{article}
\usepackage[latin1]{inputenc}
\usepackage{vmargin}
\usepackage[catalan]{babel}
\usepackage{graphicx}

\setmargnohfrb{2.5cm}{2.5cm}{2.5cm}{2.5cm}

\pagestyle{plain}

\renewcommand{\baselinestretch}{1.3}

\makeindex

\begin{document}

\tableofcontents

\newpage
\section{Com usar aquesta memòria}
\paragraph{}
%TODO ATECION QUE NO CAMBIE EL NUMERO de secciones
Aquest document està estructurat en onze seccions bàsiques. El document segueix una forma lògica i seqüencial d'explicar els conceptes de forma que no calgui anar endavant i enrera per entendre les idees, per aquesta raó pot semblar que en algun moment s'estigui repetint alguna explicació, però el que pasa es que s'està parlant del mateix però ampliant la explicació. Les seccions de la memòria són:
\begin{enumerate}
\item \textit{Com usar aquesta memòria} - Aquesta secció explica quins continguts es poden trobar a cadascuna de les seccions per tal que el lector pugui decidir si pot saltar-se alguna ja que els conceptes dels quals es parlen ja li són coneguts així com veure quines seccions expliquen coses que ell desconeix i per tant ha d'estar més concentrat per la seva lectura.
\item \textit{Objectius i motivacions} - En aquesta secció es parla dels objectius que es volen asolir amb la realització d'aquest projecte final de carrera i les motivacions que han dut a l'alumne a fer-lo.
\item \textit{Introducció} - %TODO Aquesta part de la memòria és aquella part que algú que ja tingués coneixements sobre gràfics, interfícies gràfiques, l'algorisme ROAM, etc. podria saltar-se, es a dir, és la secció que explica els conceptes per entendre tot allò que s'utilitzarà en la realització del projecte.
\item \textit{Especificació} - Aquesta secció explica tot allò relacionat amb l'especificació: el model conceptual, el model de casos d'ús, els requeriments funcionals i no funcionals, etc.
\item \textit{Disseny} - Aquesta secció explica el pas de l'especificació al disseny, hi podem trobar un model conceptual modificat per acomodar-se als requeriments juntament amb els diagrames de sequència.
\item \textit{Implementació} - Aquesta part de la memòria parla de tot allò relacionat amb la programació del projecte però que no forma part ni de l'especificació ni del disseny, com per exemple la explicació sobre l'eina escollida per la generació automàtica de Makefiles.
\item \textit{Recursos i Anàlisi de costos} - En aquesta secció es parla de tot allò que ha fet falta per realitzar el projecte, la seva planificació i l'anàlisi de quan hauria costat desenvolupar aquest projecte en cas qe s'haguès tractar d'un projecte comercial.
\item \textit{Conclusions} - Aquesta part de la memòria explica que s'ha après en la realització d'aquest projecte així com possibles modificacions futures que es podrien dur a terme.
\item \textit{Bibliografia} - Aquesta secció és una relació de totes les fonts consultades en la realització del projecte.
\item \textit{Índex de figures} - En aquesta secció hi ha un llistat de totes les figures que es troben a la memòria de forma que en cas que el lector vulgui localitzar una pugui fer-ho de ràpidament.
\item \textit{Annex} - Explicacions sobre temes no estrictament relacionats amb el projecte que poden ser d'ajuda per acabar d'entendre algunes parts de la memòria.
\end{enumerate}

\newpage
\section{Objectius i motivacions}
\paragraph{}
Els continguts relacionats amb els objectius que es volen asolir amb aquest projecte són una sintetització dels requisits expressats a la secció \ref{sec:especificacio}.

\paragraph{}
L'objectiu principal d'aquest projecte és la implementació de l'algorisme ROAM. Per aconseguir-ho tant el projectista com el director del projecte han decidit que la realització del projecte acabarà materialitzant-se en una aplicació amb una llicència de programari lliure. Aquesta aplicació implementarà l'algorisme ROAM així com lectors de diferents formats de fitxers per obtenir dades que puguin fer funcionar l'algorisme i una interfície simple per tal que l'usuari pugui controlar l'aplicació amb facilitat.

\paragraph{}
Com a objectius secundari, es vol que l'aplicació sigui el més portable possible. La portabilitat es vol a dos nivells, el primer dels nivells és la indepèndencia de sistema operatiu, el segon nivell de portabilitat que es desitja és que la interfície gràfica utilitzada per interactuar amb el nucli de l'aplicació que implementa l'algorisme ROAM es pugui canviar sense problemes.

\paragraph{}
Les motivacions per realitzar el projecte són variades, però es poden resumir en els següents punts:
\begin{itemize}
\item El món dels gràfics tridimensionals generats per computador és un món en expansió, no tan sols els videojocs han passat a generar una quantitat de beneficis superior a la del cinema, sinó que hi ha gran demanda d'aplicacions de visualització tridimensional, especialment per a temes mèdics, però també en d'altres camps. Per tant, la realització d'un projecte de final de carrera en aquest camp ajuda a obtenir coneixements sobre aquest camp amb tanta projecció que molt possiblement siguin útils en el futur.
\item El món dels gràfics per computador sempre m'ha interessat de manera especial. Per aquesta raó he cursat quasi totes les asignatures que s'imparteixen a la FIB relacionades amb aquest tema, per tant, aquest camp va ser el primer en el que vaig començar a buscar projectes de final de carrera, un altre camp que també m'interessa, i del qual també vaig mirar els projectes disponibles, és el del món del programari lliure.
\item Un cop analitzats tots els projectes que els professors vinculats a la FIB oferien relacionats amb el món dels gràfics per computador i del programari lliure, vaig anar a parlar amb en Lluís que em va explicar en profunditat de que tractava aquest projecte així com també hem va comunicar que la seva idea era que es desenvolupés com a programari lliure. Això significava que aquest projecte conjugava els dos camps que m'interessaven i, per tant, vaig decidir que si en Lluís estava d'acord en que jo el portés a terme, el projecte de la implementació de l'algorisme ROAM era el projecte que jo desitjava fer.
\end{itemize}

\newpage
\section{Introducció}

\subsection{Representació interactiva de terrenys en 3D}
\paragraph{}
La representació 3D de terrenys pot ser trivial o extremament complicada. Hi ha aplicacions en que el terra és molt poc important i amb un polígon texturat i pla quasi bé ja n'hi ha prou, la majoria de jocs 3D entren dintre d'aquestes aplicacions, jocs de cotxes, arcades 3D, etc. En canvi hi ha un conjunt d'aplicacions on el terreny es part molt important de la visualització, dins d'aquest grup podem trobar els jocs de simulació, sobretot els d'avions, però també jocs de simulació tàctica on el terreny pot permetre amargar-nos dels enemics, etc., evidentment totes les aplicacions que tinguin alguna cosa veure amb els mapes també tenen als terrenys com a part important.
\paragraph{}
A les aplicacions del primer grup, usar un algorisme especial per representar el terreny no té cap sentit, ja que aquest està format per pocs polígons i no cal fer cap optimització per representar-lo. En canvi les aplicacions on l'orografia té un paper important, la visualització del terreny pasa a ocupar gran part dels cicles de rellotge que gastarà la nostra aplicació i, per tant, un algorisme optimitzat és necessari. A més a més, en la majoria dels casos no serà únicament necessari per optimizar l'aplicació, sinó que serà completament necessari per tal que l'aplicació pugui funcionar, ja que si volguèssim representar tot el terreny faria falta un nombre ingent de triangles. Per exemple, si fem servir un esquema de representació com el de la figura \ref{fig: ingent}, què és bastant dolent ja que semblaria que el terreny tinguès forma de en serreta, però que crea un triangle entre cada punt i els seus dos més propers, per un terreny quadrat de $NxN$ punts, caldrien $2 * (N-1)^2$, cosa que significa que per un terreny de $1000x1000$ punts (res exagerat), caldrien uns dos milions de triangles, una quantitat massa elevada.

\begin{figure}[h]
\centering
\includegraphics{images/ingent.png}
\caption{Esquema de representació de terrenys}
\label{fig: ingent}
\end{figure}

\paragraph{}
Degut a aquesta necessitat d'optimització surgeixen els algorismes de representació dinàmica de superfícies. Aquests algoritmes intenten aconseguir malles de triangles que representin la superfície de forma tridimensional el més acuradament possible d'una forma eficient. El requisit de la eficiència ve donada per la interactivitat, ja que com es comenta a l'annex \ref{sec:intvsreal} \textit{(Gràfics interactius vs Gràfics realistes)}, els gràfics interactius necessiten acualitzar la imatge vàries vegades per segon. Per aconseguir tots dos objectius (representació acurada i velocitat), que en principi es contradiuen, el que fa la majoria d'algorismes és generar una malla de triangles potencialment diferent per cada posició de l'observador. D'aquesta manera s'intenta generar una malla de triangles que sigui la òptima per aquesta posició, on òptima significa ser el més acurada possible per allò que és aprop de l'observador i alhora suficientment ràpida per poder-se visualitzar de forma interactiva. La posició de l'observador és clau en aquest aspecte ja que no cal tenir una gran exactitud en la representació de parts de la superfície que es trobin molt lluny de l'observador.

\subsection{L'algorisme ROAM}

\subsection{El format DEM}
\paragraph{}
El format DEM\footnote{Especificació: http://rockyweb.cr.usgs.gov/nmpstds/acrodocs/dem/2DEM0198.PDF} (Digital Elevation Model) va ser creat per l'USGS \textit{(United States Geological Survey)} per guardar la informació de les seves mesures de la superfície dels Estats Units.
\paragraph{}
Un fitxer DEM està organitzat en tres tipus de registres lògics: A, B i C. 
\begin{itemize}
\item El tipus de registre A conté informació en quant a les característiques generals del mapa, nom, límits, unitats de mesura, elevació mínima i màxima, el número de registres de tipus B, etc. Només hi ha un registre de tipus A per fitxer.
\item Els registres de tipus B contenen la informació de les alçades propiament dita.
\item El tipus de registre C conté estàdistiques en quant a l'exactitud de les dades del fitxer.
\end{itemize}
\paragraph{}
Degut a que el format DEM estava pensat per emmagatzemar-se en cintes magnètiques, l'especificació del format parla de registres físics, cadascun de 1024 bytes. En un registre físic no hi pot haver més d'un registre lògic, en canvi és usual que els registres lògics de tipus B ocupin més d'un registre lògic. Les parts d'un registre físic no ocupades per la informació d'un registre lògic s'han d'omplir amb blancs. Els registres lògics de tipus A i C mai ocupen més d'un registre físic.
\paragraph{}
Els fitxers DEM divideixen el mapa en una graella i proporcionen l'alçada de cadascun dels punts de la graella. Cada registre de tipus B té la informació de les alçades d'una columna d'aquesta graella, es a dir, si la graella d'un mapa tinguès n columnes i m files hi hauria n registres de tipus B cadascun amb m alçades.
\paragraph{}
Hi ha tres tipus de fitxers DEM:
\begin{enumerate}
\item \textbf{DEM d'1 grau:} Tenen 1201*1201 punts de dades, estan basats en latitud-longitud i l'espaiat entre els punts de la graella és de 3 segons d'arc, que és aproximadament 90 metres, encara que obviament depèn de la latitud del planeta en que s'hagin pres les mesures.
\item \textbf{DEM de 30 minuts:} Són 4 unitats de fitxers DEM d'1 grau distribuïdes de forma conjunta, són el menys comú dels 3 tipus.
\item \textbf{DEM de 7.5 minuts:} L'espaiat entre els punts de la graella pot ser de 30 o 10 metres (1 segon d'arc i 1/3 de segon d'arc respectivament), els límits del fitxer estan basats en latitud-longitud, però en canvi els punts de dades es donen en coordenada x-y d'una projecció Mercator, resultant en fitxers on no tots registres de tipus B tenen la mateixa longitud. (Figura \ref{fig: dem})
\end{enumerate}

\begin{figure}[h]
\centering
\includegraphics{images/dem75.png}
\caption{Esquema d'un DEM de 7.5 minuts}
\label{fig: dem}
\end{figure}

\newpage
\section{Especificació}
\label{sec:especificacio}

\subsection{Què és libroam?}
libroam és la part del projecte que implementa l'algorisme ROAM. Està programada com a llibreria de forma que qualsevol programa pugui usar aquesta funcionalitat. La llibreria està sota llicència GPL (Annex \ref{sec:gpl})  La llibreria funciona fent servir el paradigma de navegació fly. Per veure una descripció dels diferents paradigmes de navegació aplicables als gràfics 3D consulteu l'annex \ref{sec:parnav}

\subsection{Què és r3v?}
r3v és una aplicació que utilitza la llibreria libroam per tal de proporcionar un visor de superfícies que utilitzi l'algorisme ROAM. L'aplicació afegeix sobre la llibreria una interfície gràfica d'usuari basada en la llibreria Qt (Annex \ref{sec:qt}) que permet a l'usuari obrir i tancar mapes, així com visualitzar-los i navegar per ells.

\subsection{Requeriments no funcionals}
\label{sec:reqnf}

%TODO EXPLICAR QUE SON???

\begin{itemize}
\item \textbf{Traduibilitat:} Que la interfície gràfica del programa es pugui traduir a tots els idiomes que es desitgi és un requeriment important, així s'amplia el públic potencial al qual anirà dirigida l'aplicació, ja que no tothom té coneixement d'anglés.
\item \textbf{Portabilitat:} Es Vol que tant r3v com libroam es puguin compilar, i per tant, executar a la majoria de sistemes disponibles.
\item \textbf{Independència entre la interfície i l'algorisme:} Es vol que la implementació de la interfície gràfica sigui el més independent possible de l'algorisme ROAM, per tal que si en algun moment es vol fer una interfície gràfica usant un altre toolkit que no sigui Qt es pugui reutilitzar la majoria del codi.

\end{itemize}

\subsection{Requeriments funcionals}


\newpage
\subsection{Model Conceptual}

\paragraph{}
\begin{figure}[h]
\centering
\includegraphics{images/especificacioSimple.png}
\caption{Diagrama de classes del domini}
\end{figure}

\subsubsection{Restriccions d'integritat}
\begin{itemize}
\item %TODO ARGGGGGGGGG ERA ALGO CON LOS BUCLES
\end{itemize}

\newpage
\subsubsection{r3vMap}
\begin{figure}[h]
\centering
\includegraphics{images/mapa.png}
\caption{Classe r3vMap}
\end{figure}
\paragraph{Descripció informal:} La classe $r3vMap$ és la classe encarregada d'emmagatzemar la informació dels mapes, per aquest fi té els següents membres i operacions:
\begin{itemize}
\item $heights$: emmagatzema les alçades de tots els punts disponibles al mapa en forma de vector de vectors.
\item $byColumns$: indica si aquest vector de vectors és un vector de files o un vector de columnes. 
\item $minHeight$: indica la alçada mínima del mapa.
\item $amplitude$: indica la diferència entre alçada màxima i alçada mínima al mapa.
\item $baseDiamond$: retorna el diamant que forma la base del mapa
\item $calcAmplitude$: calcula els valors $minHeight$ i $amplitude$
\item $height$: retorna l'alçada del punt donat
\item $triangles$: retorna el nombre de triangles que hi representant el mapa actualment
\item $leaves$: retorna el nombre de triangles fulla que hi representant el mapa actualment
\item $getNode$: retorna el nodre que representa el punt donat
\item $size$: retorna la mida del mapa, és a dir, la longitud de cadascun dels vectors de $heights$
\item $color$: retorna el color que ha de representar l'alçada donada
\end{itemize}  

\newpage
\subsubsection{Parsers}
\paragraph{}
\begin{figure}[h]
\centering
\includegraphics{images/parsers.png}
\caption{Classes parsers}
\end{figure}
Aquestes clases són les encarregades de interpretar fitxers que representen mapes i retornar la representació en forma de $r3vMap$.
\begin{itemize}
\item \textbf{\textit{r3vParser}} és una clase abstracte que defineix la operació $parse$ que tots els interprets de mapes han d'implementar.
\item \textbf{DEMParser} és un clase que implementa un interpret de mapes en format DEM.
\item \textbf{PMParser} és un clase que implementa un interpret de mapes en format pla %TODO EXPLICAR QUE ES UN MAPA EN FORMAT PLA.
\end{itemize}


\newpage
\subsection{Model de casos d'ús}

\subsubsection{Diagrama de casos d'ús}
\paragraph{}
\begin{figure}[h]
\centering
\includegraphics{images/casosUs.png}
\caption{Diagrama de casos d'ús}
\label{fig: casosUs}
\end{figure}

\subsubsection{Cas d'ús obrirMapa}
\textbf{Cas d'ús:} obrirMapa \newline
\textbf{Actors:} Usuari r3v \newline
\textbf{Propòsit:} Obrir un mapa per tal de visualitzar-lo \newline
\textbf{Tipus:} Primari essencial \newline
\textbf{Curs típic d'esdeveniments:} \newline
\begin{tabular}{ll}
\textbf{Accions dels actors} & \textbf{Resposta del sistema} \\
   1. L'usuari prem l'opció d'obrir un mapa &  \\
 & 2. El sistema mostra els fitxers que es \\
 & poden obrir \\
   3. L'usuari selecciona quin és el fitxer &  \\
   que vol obrir &  \\
 & 4. El sistema obre el mapa contingut \\
 & en aquell fitxer i el mostra \\
\end{tabular}

\subsubsection{Cas d'ús navegar}
\textbf{Cas d'ús:} navegar \newline
\textbf{Actors:} Usuari r3v \newline
\textbf{Propòsit:} Navegar per la visualització del mapa \newline
\textbf{Tipus:} Primari essencial \newline
\textbf{Curs típic d'esdeveniments:} \newline
\begin{tabular}{ll}
\textbf{Accions dels actors} & \textbf{Resposta del sistema} \\
   1. L'usuari prem alguna de les tecles &  \\
   que permet navegar per la visualització &  \\
 & 2. El sistema calcula la nova posició \\
 & de l'observador, actualitza la malla de \\
 & de triangles i actualitza la visualització \\
 & mostrada per pantalla \\
\end{tabular}

\subsubsection{Cas d'ús tancarMapa}
\textbf{Cas d'ús:} tancarMapa \newline
\textbf{Actors:} Usuari r3v \newline
\textbf{Propòsit:} Tancar el mapa que s'està visualitzant en aquest moment \newline
\textbf{Tipus:} Primari essencial \newline
\textbf{Curs típic d'esdeveniments:} \newline
\begin{tabular}{ll}
\textbf{Accions dels actors} & \textbf{Resposta del sistema} \\
   1. L'usuari prem l'opció de tancar el mapa \\
 & 2. El sistema tanca el mapa i  \\
 & actualitza la visualització \\
 & de forma que no mostri res \\
\end{tabular}

\subsubsection{Cas d'ús sortir}
\textbf{Cas d'ús:} sortir \newline
\textbf{Actors:} Usuari r3v \newline
\textbf{Propòsit:} Sortir de l'aplicació \newline
\textbf{Tipus:} Primari essencial \newline
\textbf{Curs típic d'esdeveniments:} \newline
\begin{tabular}{ll}
\textbf{Accions dels actors} & \textbf{Resposta del sistema} \\
   1. L'usuari prem l'opció de sortir \\
 & 2. El sistema es tanca a si mateix
\end{tabular}

\newpage
\section{Disseny}

\subsection{Model Conceptual}
%TODO
AQUI ANIRAN LES DIFERENCIES ENTRE EL MODEL CONCEPTUAL ESPECIFICAT I EL DISSENY FINAL, PER EXEMPLE NODE TINDRA EL SEU COLOR PER NO HABERLO DE PREGUTNAR(I CALCULAR) AL MAPA CADA VEGADA.

\subsection{Diagrames de seqüència}
%TODO Tots o els més importants?

%TODO AQUI, ARRIBA CON EL ROAM O EN EL ANNEX?
\subsection{Arbres binaris de triangles}
\paragraph{}
Un arbre binari de triangles és un arbre per organitzar triangles de forma jeràrquica. El triangle arrel $T = (v_a, v_0, v_1)$ és un triangle isòsceles amb àpex $v_a$. Els fills de l'arrel es defineixen partint l'arrel en dos parts fent crent una nova aresta que va des del vèrtex $v_a$ al punt mig $v_c$ de l'aresta base (aresta entre $v_0$ i $v_1$). El fill esquerre de $T$ és $T_0 = (v_c, v_a, v_0)$ mentre que el fill dret és $T_1 = (v_c, v_1, v_a)$. La resta de de l'estructura de l'arbre de triangles és una repetició recursiva del procés de partició explicat anteriorment. Dins de l'arbre cada triangle té un nivell $l$ definit pel nombre de vegades que s'ha partit al triangle arrel per arribar a generar aquell triangle en concret. A la figura \ref{fig: triangles} podem veure una representació dels nivells 0 a 5 d'un arbre binari de triangles.

\begin{figure}[h]
\centering
\includegraphics{images/triangles.png}
\caption{Representació dels nivells 0 a 5 d'un arbre binari de triangles}
\label{fig: triangles}
\end{figure}

\subsubsection{Representació de superfícies amb arbres binaris}
\paragraph{}
Per representar una superfície amb arbres binaris de triangles es fan servir dos arbres de triangles situats de forma que comparteixin la seva aresta base, d'aquesta forma es cubreix una superfície quadrada (Figura \ref{fig: diamant}). Un cop tenim una estructura que permet cubrir tot un quadrat només cal assignar a cada vèrtex una alçada $w(v)$ per tenir una forma eficient de guardar les alçades d'un terreny.

\begin{figure}[h]
\centering
\includegraphics{images/diamant.png}
\caption{Dos arbres de triangles serveixen per representar una superfície quadrada}
\label{fig: diamant}
\end{figure}

\subsubsection{Conjunts d'arbres binaris de triangles}
\paragraph{}
Una a triangulació d'arbres binaris de triangles (triangulació d'ara en endavant) és un conjunt d'arbres binaris que tenen alguna relació de veïnatge entre ells, ja sigui compartint un vèrtex o una aresta. Un cas especial de triangulació és el diamant, triangulació format per dos triangles que comparteixen l'aresta base i tenen el mateix nivell, la figura \ref{fig: diamant} és un exemple de diamant. Un fet important d'una triangulació és que donat un triangle, el triangle amb el que comparteix la base és del mateix nivell o del nivell superior. A la figura \ref{fig: triangleBase} podem veure un exemple de les dues situacions, el triangle A comparteix la base amb un triangle del seu nivell mentre que el triangle B comparteix la base amb un triangle d'un nivell superior ($l$ més petita).

\begin{figure}[h]
\centering
\includegraphics{images/triangleBase.png}
\caption{Possibilitats de compartir la base}
\label{fig: triangleBase}
\end{figure}

\subsubsection{Operacions sobre diamants}
\paragraph{}
Sobre un diamant es poden realitzar dues operacions, split i merge. Split (partir) consisteix en crear els fills de $T$ i del seu triangle base $T_B$ de forma que s'obté una triangulació formada pels triangles $T_1$, $T_2$, $T_B1$ i $T_B2$. Merge (fusionar) consisteix en tornar als triangles $T$ i $T_B$ a partir dels seus quatre fills. Es pot veure una representació dels processos de partició i unió a la figura \ref{fig: splitMerge}.

\begin{figure}[h]
\centering
\includegraphics{images/splitMerge.png}
\caption{Split i merge sobre una triangulació}
\label{fig: splitMerge}
\end{figure}

\paragraph{}
Només els triangles que tenen el mateix nivell que el triangle amb el que comparteixen la base són susceptibles de ser partits. Aquells que comparteixen la base amb un triangle de nivell superior ($l$ més petita) (per exemple el triangle B de la figura \ref{fig: triangleBase})  no poden ser partits directament i si realment volem partir-los hem de fer abans un split del triangle amb el que comparteix la base. La figura \ref{fig: forceSplitExtrem} és un cas extrem en el que caldria fer 4 splits forçats abans de fer la partició del triangle $T$.

\begin{figure}[h]
\centering
\includegraphics{images/forceSplitExtrem.png}
\caption{Cas extrem en el que cal aplicar 4 particions forçades}
\label{fig: forceSplitExtrem}
\end{figure}

\paragraph{}
En primera instància es pot pensar que no seria necessari que l'operació de split s'apliquès sobre un diamant i que es podria fer sobre un triangle sol, però això no es possible ja que crearia una discontinuitat en la superfície. A la figura \ref{fig: discontinuitat} veiem la representació resultant de partir només un dels triangles del diamant d'una superfície en la que els punts $(0, 0)$, $(0, 1)$, $(1, 0)$ i $(1, 1)$ tenen una alçada de 0 mentre que el punt $(0.5, 0.5)$ té una alçada de 1.

\begin{figure}[h]
\centering
\includegraphics{images/discontinuitat.png}
\caption{Discontinuitat: Resultat de partir un triangle i no un diamant}
\label{fig: discontinuitat}
\end{figure}

\subsection{Escala de colors}
\paragraph{}
A l'hora de visualitzar el terreny s'ha decidit assignar-li a cada vèrtex un color que tingui a veure amb la seva alçada, d'aquesta manera és més fàcil per l'observador diferenciar les alçades de cada terreny. L'esquema que s'ha utilitzat es bastant simple, el punt més baix és de color blau, segons es va pujant d'alçada es va degradant el color cap al verd, de forma que els punts amb l'açada mitja tenen color verd, la resta de punts a més alçada tenen un color que es va degradant del verd al vermell, que és el color dels punts més alts del terreny.
\begin{figure}[h]
\centering
\includegraphics{images/cube.png}
\caption{Escala de colors que s'ha utilitzat}
\label{fig: cub}
\end{figure}

\newpage
\section{Implementació}

\subsection{Requeriments no funcionals}
\paragraph{}
En aquest capítol explicarem les decisions d'implementació que s'han pres per garantir els requeriments no funcionals mencionats a l'apartat \ref{sec:reqnf}

\begin{itemize}
\item \textbf{Traduïbilitat:} L'anglés és l'idioma en el qual s'han escrit els textos de la interfície original, ja que com és l'idioma més extés, és més fàcil trobar traductors per a la resta d'idiomes, en canvi si els textos estiguessin originalment en català o castellà la quantitat de traductors es reduiria de forma considerable. Tots els textos de l'aplicació estan a la part de r3v i no a la part de la llibreria libroam, això ha permés utilitzar les facilitats proporcionades per Qt per la traducció de programes. S'han utilitzat els programes lupdate, lrelease i linguist i la funció tr() que marca els textos que han de ser traduïts i els tradueix en cas que existeixi la traducció d'aquesta cadena a l'idioma que s'està utilitzant.
\begin{itemize}
\item lupdate és el programa que s'encarrega de llegir els fitxers del codi font, buscar els textos que han de ser traduïts i actualitzar fitxers .ts que és on els traductors han de fer les traduccions.
\item linguist és el programa que han d'utilitzar els traductors per escriure les traduccions de cada una de les cadenes de text que s'han de traduir.
\item lrelease és el programa que transforma els fitxers .ts en fitxers .qm. Els fitxers .qm són representacions binàries de la traducció que utilitza el programa un cop s'està executant.
\end{itemize}
Cada cop que s'executa el programa r3v en un ordinador es consulta la variable \textit{QLocale::system().name()} que dòna el nom del l'idioma que s'està usant en el sistema operatiu, amb aquest nom es cerquen les traduccions disponibles, si n'hi ha alguna que concorda es fa servir aquesta, si no hi ha traducció a aquest idioma es fan servir els textos en anglès.

\item \textbf{Portabilitat:} Per aconseguir que tant r3v com libroam es puguin compilar, i per tant, executar a la majoria de sistemes disponibles s'ha pres la decisió d'utilitzar C++ i la seva llibreria estàndard per a la programació, ja que C++ és un llenguatge pel qual hi ha compiladors disponibles per la majoria de sistemes operatius. D'igual manera la interfície està feta en Qt, un toolkit en C++ que permet crear interfícies gràfiques d'usuari i té versions per a Linux/Unix, Mac OS i Windows. Finalment hi ha el problema de portabilitat de la API 3D, això s'ha ressolt utilitzant OpenGL, una API 3D que també té implementacions per a la majoria de sistemes operatius actuals. Per conèixer més a fons que és una API 3D podeu consultar l'annex \ref{sec:api3d}

\item \textbf{Independència entre la interfície i l'algorisme:} Per aconseguir que la implementació de l'algorisme sigui independent de la interfície gràfica, s'ha programat l'algorisme com a una llibreria que utilitza tan sols C++ i les classes que proporciona la llibreria estàndard de C++, d'aquesta manera el canviar de Qt a un altre sistema per crear interfícies gràfiques com Gtk només suposa reescriure la classe que s'ocupa de gestionar els events de teclat i ratolí, tota la resta és completament independent.

\end{itemize}



\subsection{Generació de Makefiles}
\paragraph{}
Qt té la seva pròpia eina per la generació automàtica de Makefiles anomenada Qt, però com ja s'ha comentat no volem dependre de Qt, per tant, hi havia dos opcions, la creació manual dels Makefiles o usar un generador automàtic de Makefiles que sigui \textit{neutre}. La creació manual de Makefiles va quedar descartada ràpidament, ja que era una opció més pesada i menys potent, per tant s'havia de decidir quin generador automàtic usar. Aquesta decisió tampoc va ser gaire complicada, ja que encara que hi ha una varies eines que poden fer aquesta tasca, autotools és la més comú i es pot trobar a quasi totes les distribucions de Linux i a també funciona a quasi tots els Unix.

\subsection{Autotools}
\paragraph{}
Encara que sovint es parla d'Autotools (tal i com es farà en aquest document), Autotools és en realitat un paraula utilitzada per referir-se a un conjunt d'eines el nom de les quals comença per auto-, com autoheader, automake i autoconf. La sintaxi dels fitxers utilitzats per les autotools pot semblar complicada inicialment però si ens limitem a fer coses simples com les que fa aquest projecte (compilar una llibreria i un ejecutable que depèn d'ella) es força potent i fàcil de fer servir.

\paragraph{}
Autoconf és l'eina que serveix per comprovar que la plataforma en la que es compilarà el programa té les eines i llibreries que calen. A part, també serveix per detectar particularitats de la plataforma, per exemple si en aquesta plataforma una funció te uns paràmetres no estàndard, i definir uns símbols que més tard farem servir en el codi font per adaptar-nos a totes les plataformes. Per part del programador només s'ha de crear el fitxer configure.in que conté paraules clau que indiquen totes les comprovacions que volem fer, a partir d'aquest fitxer, autoconf genera un script anomenat configure que en executar-se en l'ordinador que està compilant el programa fa les comprovacions i avisa en cas de que alguna condició no és compleixi.

\paragraph{}
Per aquest projecte el fitxer configure.in es limita a comprovar l'existència d'un compilador de C++, que l'eina libtool es trobi instal·lada al sistema i finalment fa la comprovació de si Qt està instal·lat. En el cas de Qt es comprova si la versió instal·lada és 3.x o 4.0 i es defineix el simbol Qt4 de forma que el programa funcioni tant amb les versions 3.x com amb la versió 4.0 (que com s'ha esmentat anteriorment encara no té versió final, però ja hi ha versions preliminars suficientment funcionals per compilar aquest projecte).

\paragraph{}
Automake és l'eina que serveix per generar els Makefile. De forma ràpida un Makefile és un fitxer que indica com s'ha de compilar un programa i la depèndencia dels fitxers entre si, de forma que en canviar un fitxer es tornin a recompilar només aquells que tenen alguna relació. Aquesta eina genera fitxers Makefile.in a partir de fitxers Makefile.am, els fitxers Makefile.in es converteixen en fitxers Makefile al executar-se el configure creat per Autoconf. Als fitxers Makefile.am només cal indicar quines són les llibreries i els fitxers de codi font que utilitza en nostre programa/libreria i Automake s'encarrega de generar un Makefile complet amb els típics install, clean, uninstall, etc.

\paragraph{}
Per aquest projecte hem utilitzat fitxers Makefile.am per generar la llibreria libroam i per generar l'executable r3v, les opcions usades han estat bastant simples, al fitxer Makefile.am de libroam s'ha indicat que volem que sigui una llibreria estàtica generada per libtool formada per tots els fitxers .cpp del directori i a més a més usant les llibreries GL i GLU. Per a l'executable r3v, s'ha indicat que es volia generar un executable usant el codi de la interfície en Qt i usant la llibreria libtool així com la llibreria Qt.

\paragraph{}
L'ús de les autotools presenta un \textit{petit problema} en quant a la portabilitat del projecte, ja que no hi ha versió nativa de les autotools per a Windows. Això significa que el projecte no pot ser compilat directament sota Windows, cal adaptar-lo a les eines del compilador de C++ que s'usi; un petit problema de portabilitat però que no afecta de cap manera que el codi del programa continui sent portable.


\subsection{Lector de format DEM}
\paragraph{}
El format DEM dòna moltes més dades de les necessàries per implementar un visualitzador de superfícies, com ara, nom del mapa, descripció sobre el mapa, coordenades a les que es troba el mapa, estadistiques sobre la exactitud dels valors, etc. Aquestes dades poden ser molt interessants, però no en el nostre context, per tant, s'ha decidit que la implementació del lector de fitxers de format DEM per a crear un objecte de la classe r3vMap, ignori tots aquest valors i es centri en les dades d'altitud.


\newpage
\section{Recursos i Anàlisi de costos}
\subsection{Recursos humans i tecnològics}
\subsection{Anàlisi de costos}
\newpage
\section{Conclusions}
\newpage
\section{Bibliografia}
\newpage
\section{Índex de figures}
\listoffigures
\newpage
\section{Annex}

\subsection{Gràfics per computador}
\paragraph{}
Els gràfics per computador és un camp de la computació en el qual s'utilitzen els ordinadors per generar imatges, ja siguin completament sintètiques o generades a partir d'informació obtinguda del món real.

\paragraph{}
Els gràfics per computador tenen dos grans camps, els gràfics 2D i els gràfics 3D.


\subsubsection{Gràfics 2D}
\paragraph{}
Els gràfics 2D són aquells que representen imatges bidimensionals en pantalla. Hi ha dos tipus bàsics d'imatges 2D, els mapes de bits i les imatges vectorials.

\paragraph{}
Els mapes de bits són bàsicament una graella de píxels bidimensional. Cada píxel té una posició assignada dintre de la graella i emmagatzema el seu color. Un mapa de bits te una resolució finita determinada pel nombre de columnes i files, i per tant si es vol fer mostrar més gran del que realment és, sol aparèixer l'efecte de pixelació consistent en que l'observador de la imatge és capaç de disintigir cada un dels píxels de forma separada, cosa que no pasa quan la imatge es visualitza amb la seva mida real.

\paragraph{}
Les imatges vectorials tenen les dades geomètriques de forma precisa. Els punts es donen en un sistema de coordenades, les dades de la imatge vectorital també contenen la descripció de les connexions entre els punts(per formar línies o rutes), el color de cada punt o línia, el gruix de cara línia o secció, etc. La majoria de sistemes gràfics vectorials també tenen primitives pels tipus de formes més bàsics con els cercles o rectangles. Aquestes dades permeten generar la imatge des de zero. El fet que la imatge estigui guardada amb una descripció de com s'ha de \textit{crear}, permet que les imatges vectorials no sofreixin mai de l'efecte de pixelació encara que també les fa més lentes de visualitzar. Per visualitzar una imatge vectorial s'ha d'acabar creant un mapa de bits.


\subsubsection{Gràfics 3D}
\paragraph{}
Els gràfics 3D tenen dos branques bastant diferenciades, els gràfics 3D per ser visualitzats en una pantalla (ja sigui d'ordinador, televisió, etc.) i els gràfics tridimensionals que es representen de forma volumètrica usant diferents aparells. En aquest document ens centrarem en explicar els gràfics 3D per ser visualitzats en pantalla ja que els altres estan menys desenvolupats i a més a més no tenen cap relació amb l'objectiu del projecte.

\paragraph{}
Els gràfics 3D es diferencien dels gràfics 2D principalment pel fet que en els gràfics 3D hi ha una representació virtual tridimensional dels objectes de l'escena que s'utilitza per fer els cálculs i per obtenir la imatge 2D que finalment s'acabarà representant en pantalla mentre que en els gràfics 2D o bé no hi ha objectes (mapa de bits) o els objectes són bidimensionals (imatges vectorials). En general, els gràfics 3D es poden comparar amb una fotografia d'una escultura, mentre que els gràfics 2D es correspondrien amb un dibuix.

\paragraph{}
CONTINUARRRRRRRRR \newline
CONTINUARRRRRRRRR

\subsubsection{Gràfics interactius vs Gràfics realistes}
\label{sec:intvsreal}
\paragraph{}
Dins dels gràfics generats per computador (ja siguin 2D o 3D) hi ha dos grans branques. Els gràfics interactius i els gràfics realistes.

\paragraph{}
Els gràfics interactius són aquells en els que l'observador pot influir en la generació dels gràfics. És a dir, l'usuari del programa pot rotar, moure, escalar, etc. els objectes de l'escena a voluntat. Això és útil per a jocs, simuladors i visualitzadors de dades en general. La característica principal que es demana a aquests gràfics és la velocitat de generació, que ha d'estar al voltant de les 25 actualitzacions per segons, de forma que l'observador vegi una suavitat en el moviment, per sota de les 15 actualitzacions per segon el moviment comença a semblar que vagi a salts. Per aquesta raó també se'ls sol anomenar gràfics en temps real. Degut a que la velocitat és el principal factor en aquests tipus de gràfics la qualitat no és molt gran, encara que gràcies a que les targetes acceleradores estan evolucionant molt ràpid, la qualitat ha pujat molt en poc temps. La base d'aquest tipus dels gràfics en el món 3D són els triangles, tot es genera a partir d'una acumulació de triangles, fins i tot les cercles.

\paragraph{}
Els gràfics realistes són aquells on el que prima és que la imatge generada s'asembli el més possible a una imatge real. El destí principal d'aquest tipus de gràfics són les pel·lícules, anuncis, etc. que gràcies als gràfics realistes poden incloure imatges que abans serien o molt cares de fer o, fins i tot, impossibles de rodar. Aquest fet condiciona la velocitat de generació de les imatges i de vegades es triga hores en aconseguir una sola imatge estàtica, per tant, aquest mètode encara que aconsegueix imatges d'una qualitat espectacular no serveix per fer gràfics interactius. A la generació de gràfics 3D s'usen mètodes que utilitzen fòrmules matemàtiques que intenten modelar el comportament real de la llum.



\subsection{API 3D}
\label{sec:api3d}
\paragraph{}
Una API (\textbf{A}pplication \textbf{p}rogramming \textbf{i}nterface) és un conjunt de definicions com un component de software interactua amb un altre. És un mètode per aconseguir abstracció entre capes diferents de software, ja sigui entre capes de diferents nivells com de capes del mateix nivell que es dediquen a tasques diferents.

\paragraph{}
Una API 3D és una API que defineix les funcions necessàries per crear gràfics tridimensionals. Avui en dia hi ha dos APIs 3D dominants per la generació de gràfics interactius, OpenGL i Direct3D. Totes les APIs 3D per generar gràfics interactius serveixen també per generar gràfics 2D interactius ja que només cal fer que tots els objectes 3D es situin en un mateix pla per fer que el mon 3D sigui bidimensional.

\subsubsection{OpenGL}
\paragraph{}
OpenGL (\textbf{Open} \textbf{G}raphics \textbf{L}ibrary) és una especificació d'una API d'un llenguatge per escriure aplicacions que produeixen gràfics 3D. OpenGL és un estàndard definit per la \textit{OpenGL Architecture Review Board}, formada per molt membres de la indústria dels computadors, ja siguin constructors d'ordinadors, de sistemes operatius o de hardware gràfic. Alguns dels membres són Apple, ATI Technologies, Dell, Hewlett-Packard, IBM, Intel, Nvidia, SGI, etc. cosa que converteix OpenGL en un estàndard realment neutral i amb suport per la gran majoria de les plataformes gràfiques.

\paragraph{}
OpenGL va ser introduït el 1992 com a evolució de la interfície 3D IRIS GL de SGI. Un dels problemes de IRIS GL era que tot el que implementava la llibrera havia d'estar suportat pel hardware i per tant si el hardware que no suportava una caracterísitica que es feia servir al programa, aquest no es podia executar. OpenGL va solucionar aquest problema proporcionant suport software per a les característiques que el hardware no tenia, cosa que en aquell moment va permetre executar programes 3D en sistemes no tan cars com els que fabricava SGI.

\paragraph{}
Les caracterísitiques bàsiques d'OpenGL són:
\begin{itemize}
\item \textbf{Multillenguatge:} Hi ha llibreries que permeten utilitzar OpenGL des de C, C++, Fortran, Ada, Java, Perl, Python, Visual Basic, etc. Per tant, es pot reutilitzar el codi OpenGL d'una aplicació en un llenguatge per programar la mateixa aplicació o similar en un llenguatge diferent.
\item \textbf{Multiplataforma:} OpenGL està disponible per a Windows, Mac OS, Unix comercials, Linux i d'altres sistemes operatius menors, per tant una aplicació que utilitzi OpenGL no està limitada a executar-se en un sistema operatiu en particular.
\item \textbf{Estable:} La API d'OpenGL s'ha mantingut bastant estable durant més de 7 anys. Això permet que els programes continuin funcionant sense problemes amb noves versions i a més a més facilita la feina dels programadors que no han d'anar modificant els seus coneixements cada poc temps.
\end{itemize}

\subsubsection{Direct3D}
\paragraph{}
Direct3D és la part que s'encarrega de la visualització tridimensional de la API DirectX de Microsoft. Només hi ha versions de DirectX (i per tant de Direct3D) per als sistemes operatius de Microsft (Windows 95 en endavant) encara que la consola XBox (produïda per Microsoft) té una API molt similar a la de DirectX.
\paragraph{}
Hi ha moltes versions de DirectX, cadascuna afegeix noves característiques sobre la anterior. Això és útil en un món que es mou tan ràpidament com els dels gràfics per computador però també suposa que els programadors han d'anar readaptant el seu coneixement sobre la llibreria per poder programar per les últimes versions.

% CUÑAAAAAAAAA NO HAS EXPLICAO LO Q ES UNA MALLA DE TRIANGULOS :_D
% CUÑAAAAAAAAA LOS BASICOS 3D :_D

\subsubsection{Primitives gràfiques 3D}
La majoria d'API per la generació de gràfics 3D interactius tenen un conjunt similar de primitives, és a dir, \textit{d'objectes} que podem fer servir per contruir una escena. En aquesta secció ens centrarem en les primitives que té OpenGL.

\begin{itemize}
\item \textbf{GL\_POINTS} - Cada punt que es dona es converteix en un punt a l'espai.
\item \textbf{GL\_LINES} - Cada dos punts que es donen es converteixen en una línia.
\item \textbf{GL\_LINE\_STRIP} - Donats $i$ punts, es creen $i-1$ línies. Els punts que uneix una línia amb índex $k$ són els $k$ i $k+1$.
\item \textbf{GL\_LINE\_LOOP} - Donats $i$ punts, es creen $i$ línies. Els punts que uneix una línia amb índex $k$ són els $k$ i $k+1$ per $0<k<i-1$ i els $i$ i el $0$ per l'última línia ($k = i$).
\item \textbf{GL\_TRIANGLES} - Cada 3 punts que es donen es converteixen en un triangle.
\item \textbf{GL\_TRIANGLE\_STRIP} - Donats $i$ punts, ($i>3$) es creen $i-2$ triangles. El triangle amb índex $k$ està format pels punts amb índex $k$, $k+1$ i $k+2$.
\item \textbf{GL\_TRIANGLE\_FAN} - Donats $i$ punts, ($i>=3$) es creen $i-2$ triangles. El triangle amb índex $k$ està format pels punts amb índex $0$, $k+1$ i $k+2$.
\item \textbf{GL\_QUADS} - Cada 4 punts que es donen es converteixen en un quadrilàter.
\item \textbf{GL\_QUAD\_STRIP} - Donats $i$ punts, ($i>=4$) es creen $i-3$ quadrilàters. El quadrilàter amb índex $k$ està format pels punts amb índex $k$, $k+1$, $k+2$ i $k+3$ TODO ESTA MAL CORREGIRRRRRRRRRRRR.
\item \textbf{GL\_POLYGON} - Té el mateix comportament que \textbf{GL\_LINE\_LOOP}, però en comptes de crear línies crear un polígon.
\end{itemize}
Podem veure exemples de les 10 primitives a la figura \ref{fig: primitives}

\begin{figure}[h]
\centering
\includegraphics{images/primitives.png}
\caption{Primitives gràfiques d'OpenGL}
\label{fig: primitives}
\end{figure}


\subsection{Paradigmes de navegació 3D}
\label{sec:parnav}
\paragraph{}
La navegació d'escenes 3D té tres paradigmes fonamentals, Walk, Fly i Examine. Tota aplicació 3D implementa un d'aquests paradigmes, encara que no n'ha d'implementar només un.

\subsubsection{Paradigma walk}
Al paradigma walk, l'usuari del programa pot moure la càmara i per tant navegar per l'escena. L'usuari sol estar representat per una entitat dins de l'escena anomenada avatar. L'avatar està sotmés a la gravetat i per tant només pot caminar per terrenys plans, pujar pendents poc pronunciades i xoca contra les parets. Els moviments típics de l'avatar són desplaçar-se en qualsevol de les quatre direccions (endavant, endarrera, esquerra i dreta) i gir de la càmara per enfocar cap a qualsevol direcció possible. En aquest paradigma la visió pot ser en primera persona o en tercera persona. A la visió primera persona, la càmara es situa als ulls de l'avatar, veient-se allò que veuria l'avatar, per tant, de l'avatar només es sol veure les mans i peus. A la visió en tercera persona la càmara es situa fora de l'avatar, normalment per darrera d'ell, de forma que ens permet veure la situació de l'avatar d'una manera més global. Aquesta càmara té més problemes de gestió, ja que s'ha d'anar amb compte de que la càmara no atravesi parets quan l'avatar s'apropa a elles, ja que si ho fes no veuriem l'avatar, sinó la paret. A més a més la visió en primera persona sol donar més sensació d'inmersió, per tant la majoria de programes 3D que utilitzen el paradigma walk solen optar per ella.

\subsubsection{Paradigma fly}
El paradigma fly és gairabé igual al paradigma walk, sent la no existència de la gravetat la diferència més gran. El paradigma fly se sol utilitzar en simuladors espaials o bé en els mateixos escenaris que utilitzen el paradigma walk per donar-li a l'usuari més llibertat a l'hora de reconèixer l'escena, per exemple es molt possible que als dissenyadors de pantalles els interesi poder volar per l'escenari per així poder desplaçar-se entre diferents alçades de forma més ràpida. Així mateix a vegades el paradigma fly desactiva la detecció de col·lisions permetent que l'avatar atravesi les parets.

\subsubsection{Paradigma examine}
Al paradigma examine l'observador no es mou, sempre està a la mateixa posició i mira en la mateixa direcció. La interactivitat d'aquest paradigma es a la part dels objectes i no a la de l'observador. Normalment hi ha uns quants objectes (de vegades només un) al punt on està enfocant la càmara i l'usuari put rotar, escalar, desplaçar els objectes de forma que pugui examinar l'objecte completament. Aquest paradigma es sol usar en aplicacions que permeten la visualització d'ossos, peces de maquinària, etc.



\subsection{GPL}
\label{sec:gpl}
\paragraph{}
GPL (\textbf{G}eneral \textbf{P}ublic \textbf{L}icense) és una llicència de software lliure. La llicència GPL garanteix als destinataris d'un programa informàtic els següents drets o llibertats:
\begin{itemize}
\item La llibertat per executar el programa sigui quin sigui el propòsit
\item La llibertat d'estudiar com funciona el programa i de modificar-lo (Evidentment cal tenir accés al codi com a precondició per complir això)
\item La llibertat de distribuir copies (ja siguin modificades o sense modificar)
\end{itemize}
\paragraph{}
La llicència GPL és una de les llicències de software lliure més exteses, si visitem la pàgina de SourceForge (una pàgina web on es registren projectes de software lliure per tal de desenvolupar-los usant les serveis que aquesta proporciona) que llista el número de projectes registrats per cada tipus de llicència, veiem que un 69\% (43089 dels 62291) utilitzen la llicència GPL.
\paragraph{}
Es pot trobar el text complet de la llicència a \textit{http://www.gnu.org/licenses/gpl.html}


\subsection{Qt}
\label{sec:qt}
\paragraph{}
Qt és un \textit{framework} complet de desenvolupament d'aplicacions en C++. Inclou una llibreria així com eines per la internacionalització i el desenvolupament multiplataforma d'aplicacions.
\paragraph{}
Qt aconsegueix ser multiplataforma abstraient els sistemes operatius i de gestió de finestres, de forma que proporciona una API coherent, lògica i orientada a objectes comú. Les aplicacions Qt s'executen nativament, compilades des del mateix codi font, a totes les plataformes suportades:
\begin{itemize}
\item Qt/Windows (Microsoft Windows XP, 2000, NT 4, Me/98/95)
\item Qt/X11 (Linux, Solaris, HP-UX, IRIX, AIX, i altres variants Unix)
\item Qt/Mac (Mac OS X)
\item Qt/Embedded (Linux embedded)
\end{itemize}
\paragraph{}
La llibreria inclou una gran part de classes per a la construcció d'interfícies gràfiques, encara que també proporciona moltes altres funcionalitats, com comunicació per xarxa via sockets, classes per treballar amb XML, classes per accedir a fitxers, etc.
\paragraph{}
Qt té un sistema de llicències dual que permet desenvolupar tant aplicacions lliures (sota la llicència GPL) com aplicacions propietàries. Per poder desenvolupar aplicacions propietàries s'ha de pagar una llicència de Qt per cada programador. Actualment, aquest sistema està disponible per totes les plataformes excepte per a Qt/Windows on només hi ha la posibilitat de pagar per una llicència, però la versió Qt 4.0, esperada per finals del segon quatrimestre del 2005, també usarà aquest sistema per Qt/Windows.


\end{document}
