\documentclass[a4paper,12pt]{article}
\usepackage[latin1]{inputenc}
\usepackage{vmargin}
\usepackage[catalan]{babel}
\usepackage{graphicx}

\setmargnohfrb{2.5cm}{2.5cm}{2.5cm}{2.5cm}

\pagestyle{plain}

\renewcommand{\baselinestretch}{1.3}

\makeindex

\begin{document}

\tableofcontents
\newpage
\section{Com usar aquesta memòria}
\newpage
\section{Objectius i motivacions}
\newpage
\section{Introducció}



\subsection{Gràfics per computador}
\paragraph{}
Els gràfics per computador és un camp de la computació en el qual s'utilitzen els ordinadors per generar imatges, ja siguin completament sintètiques o generades a partir d'informació obtinguda del món real.

\paragraph{}
Els gràfics per computador tenen dos grans camps, els gràfics 2D i els gràfics 3D.


\subsubsection{Gràfics 2D}
\paragraph{}
Els gràfics 2D són aquells que representen imatges bidimensionals en pantalla. Hi ha dos tipus bàsics d'imatges 2D, els mapes de bits i les imatges vectorials.

\paragraph{}
Els mapes de bits són bàsicament una graella de píxels bidimensional. Cada píxel té una posició assignada dintre de la graella i emmagatzema el seu color. Un mapa de bits te una resolució finita determinada pel nombre de columnes i files, i per tant si es vol fer mostrar més gran del que realment és, sol aparèixer l'efecte de pixelació consistent en que l'observador de la imatge és capaç de disintigir cada un dels píxels de forma separada, cosa que no pasa quan la imatge es visualitza amb la seva mida real.

\paragraph{}
Les imatges vectorials tenen les dades geomètriques de forma precisa. Els punts es donen en un sistema de coordenades, les dades de la imatge vectorital també contenen la descripció de les connexions entre els punts(per formar línies o rutes), el color de cada punt o línia, el gruix de cara línia o secció, etc. La majoria de sistemes gràfics vectorials també tenen primitives pels tipus de formes més bàsics con els cercles o rectangles. Aquestes dades permeten generar la imatge des de zero. El fet que la imatge estigui guardada amb una descripció de com s'ha de \textit{crear}, permet que les imatges vectorials no sofreixin mai de l'efecte de pixelació encara que també les fa més lentes de visualitzar. Per visualitzar una imatge vectorial s'ha d'acabar creant un mapa de bits.


\subsubsection{Gràfics 3D}
\paragraph{}
Els gràfics 3D tenen dos branques bastant diferenciades, els gràfics 3D per ser visualitzats en una pantalla (ja sigui d'ordinador, televisió, etc.) i els gràfics tridimensionals que es representen de forma volumètrica usant diferents aparells. En aquest document ens centrarem en explicar els gràfics 3D per ser visualitzats en pantalla ja que els altres estan menys desenvolupats i a més a més no tenen cap relació amb l'objectiu del projecte.

\paragraph{}
Els gràfics 3D es diferencien dels gràfics 2D principalment pel fet que en els gràfics 3D hi ha una representació virtual tridimensional dels objectes de l'escena que s'utilitza per fer els cálculs i per obtenir la imatge 2D que finalment s'acabarà representant en pantalla mentre que en els gràfics 2D o bé no hi ha objectes (mapa de bits) o els objectes són bidimensionals (imatges vectorials). En general, els gràfics 3D es poden comparar amb una fotografia d'una escultura, mentre que els gràfics 2D es correspondrien amb un dibuix.

\paragraph{}
CONTINUARRRRRRRRR \newline
CONTINUARRRRRRRRR

\subsubsection{Gràfics interactius vs Gràfics realistes}
\paragraph{}
Dins dels gràfics generats per computador (ja siguin 2D o 3D) hi ha dos grans branques. Els gràfics interactius i els gràfics realistes.

\paragraph{}
Els gràfics interactius són aquells en els que l'observador pot influir en la generació dels gràfics. És a dir, l'usuari del programa pot rotar, moure, escalar, etc. els objectes de l'escena a voluntat. Això és útil per a jocs, simuladors i visualitzadors de dades en general. La característica principal que es demana a aquests gràfics és la velocitat de generació, que ha d'estar al voltant de les 25 actualitzacions per segons, de forma que l'observador vegi una suavitat en el moviment, per sota de les 15 actualitzacions per segon el moviment comença a semblar que vagi a salts. Per aquesta raó també se'ls sol anomenar gràfics en temps real. Degut a que la velocitat és el principal factor en aquests tipus de gràfics la qualitat no és molt gran, encara que gràcies a que les targetes acceleradores estan evolucionant molt ràpid, la qualitat ha pujat molt en poc temps. La base d'aquest tipus dels gràfics en el món 3D són els triangles, tot es genera a partir d'una acumulació de triangles, fins i tot les cercles.

\paragraph{}
Els gràfics realistes són aquells on el que prima és que la imatge generada s'asembli el més possible a una imatge real. El destí principal d'aquest tipus de gràfics són les pel·lícules, anuncis, etc. que gràcies als gràfics realistes poden incloure imatges que abans serien o molt cares de fer o, fins i tot, impossibles de rodar. Aquest fet condiciona la velocitat de generació de les imatges i de vegades es triga hores en aconseguir una sola imatge estàtica, per tant, aquest mètode encara que aconsegueix imatges d'una qualitat espectacular no serveix per fer gràfics interactius. A la generació de gràfics 3D s'usen mètodes que utilitzen fòrmules matemàtiques que intenten modelar el comportament real de la llum.



\subsection{API 3D}
\paragraph{}
Una API (\textbf{A}pplication \textbf{p}rogramming \textbf{i}nterface) és un conjunt de definicions com un component de software interactua amb un altre. És un mètode per aconseguir abstracció entre capes diferents de software, ja sigui entre capes de diferents nivells com de capes del mateix nivell que es dediquen a tasques diferents.

\paragraph{}
Una API 3D és una API que defineix les funcions necessàries per crear gràfics tridimensionals. Avui en dia hi ha dos APIs 3D dominants per la generació de gràfics interactius, OpenGL i Direct3D. Totes les APIs 3D per generar gràfics interactius serveixen també per generar gràfics 2D interactius ja que només cal fer que tots els objectes 3D es situin en un mateix pla per fer que el mon 3D sigui bidimensional.

\subsubsection{OpenGL}
\paragraph{}
OpenGL (\textbf{Open} \textbf{G}raphics \textbf{L}ibrary) és una especificació d'una API d'un llenguatge per escriure aplicacions que produeixen gràfics 3D. OpenGL és un estàndard definit per la \textit{OpenGL Architecture Review Board}, formada per molt membres de la indústria dels computadors, ja siguin constructors d'ordinadors, de sistemes operatius o de hardware gràfic. Alguns dels membres són Apple, ATI Technologies, Dell, Hewlett-Packard, IBM, Intel, Nvidia, SGI, etc. cosa que converteix OpenGL en un estàndard realment neutral i amb suport per la gran majoria de les plataformes gràfiques.

\paragraph{}
OpenGL va ser introduït el 1992 com a evolució de la interfície 3D IRIS GL de SGI. Un dels problemes de IRIS GL era que tot el que implementava la llibrera havia d'estar suportat pel hardware i per tant si el hardware que no suportava una caracterísitica que es feia servir al programa, aquest no es podia executar. OpenGL va solucionar aquest problema proporcionant suport software per a les característiques que el hardware no tenia, cosa que en aquell moment va permetre executar programes 3D en sistemes no tan cars com els que fabricava SGI.

\paragraph{}
Les caracterísitiques bàsiques d'OpenGL són:
\begin{itemize}
\item \textbf{Multillenguatge:} Hi ha llibreries que permeten utilitzar OpenGL des de C, C++, Fortran, Ada, Java, Perl, Python, Visual Basic, etc. Per tant, es pot reutilitzar el codi OpenGL d'una aplicació en un llenguatge per programar la mateixa aplicació o similar en un llenguatge diferent.
\item \textbf{Multiplataforma:} OpenGL està disponible per a Windows, Mac OS, Unix comercials, Linux i d'altres sistemes operatius menors, per tant una aplicació que utilitzi OpenGL no està limitada a executar-se en un sistema operatiu en particular.
\item \textbf{Estable:} La API d'OpenGL s'ha mantingut bastant estable durant més de 7 anys. Això permet que els programes continuin funcionant sense problemes amb noves versions i a més a més facilita la feina dels programadors que no han d'anar modificant els seus coneixements cada poc temps.
\end{itemize}

\subsubsection{Direct3D}
\paragraph{}
Direct3D és la part que s'encarrega de la visualització tridimensional de la API DirectX de Microsoft. Només hi ha versions de DirectX (i per tant de Direct3D) per als sistemes operatius de Microsft (Windows 95 en endavant) encara que la consola XBox (produïda per Microsoft) té una API molt similar a la de DirectX.
\paragraph{}
Hi ha moltes versions de DirectX, cadascuna afegeix noves característiques sobre la anterior. Això és útil en un món que es mou tan ràpidament com els dels gràfics per computador però també suposa que els programadors han d'anar readaptant el seu coneixement sobre la llibreria per poder programar per les últimes versions.

% CUÑAAAAAAAAA NO HAS EXPLICAO LO Q ES UNA MALLA DE TRIANGULOS :_D
% CUÑAAAAAAAAA LOS BASICOS 3D :_D

\subsubsection{Primitives gràfiques 3D}
La majoria d'API per la generació de gràfics 3D interactius tenen un conjunt similar de primitives, és a dir, \textit{d'objectes} que podem fer servir per contruir una escena. En aquesta secció ens centrarem en les primitives que té OpenGL.

\begin{itemize}
\item \textbf{GL\_POINTS} - Cada punt que es dona es converteix en un punt a l'espai.
\item \textbf{GL\_LINES} - Cada dos punts que es donen es converteixen en una línia.
\item \textbf{GL\_LINE\_STRIP} - Donats $i$ punts, es creen $i-1$ línies. Els punts que uneix una línia amb índex $k$ són els $k$ i $k+1$.
\item \textbf{GL\_LINE\_LOOP} - Donats $i$ punts, es creen $i$ línies. Els punts que uneix una línia amb índex $k$ són els $k$ i $k+1$ per $0<k<i-1$ i els $i$ i el $0$ per l'última línia ($k = i$).
\item \textbf{GL\_TRIANGLES} - Cada 3 punts que es donen es converteixen en un triangle.
\item \textbf{GL\_TRIANGLE\_STRIP} - Donats $i$ punts, ($i>3$) es creen $i-2$ triangles. El triangle amb índex $k$ està format pels punts amb índex $k$, $k+1$ i $k+2$.
\item \textbf{GL\_TRIANGLE\_FAN} - Donats $i$ punts, ($i>=3$) es creen $i-2$ triangles. El triangle amb índex $k$ està format pels punts amb índex $0$, $k+1$ i $k+2$.
\item \textbf{GL\_QUADS} - Cada 4 punts que es donen es converteixen en un quadrilàter.
\item \textbf{GL\_QUAD\_STRIP} - Donats $i$ punts, ($i>=4$) es creen $i-3$ quadrilàters. El quadrilàter amb índex $k$ està format pels punts amb índex $k$, $k+1$, $k+2$ i $k+3$ TODO ESTA MAL INUTIIIIIIIIL.
\item \textbf{GL\_POLYGON} - Té el mateix comportament que \textbf{GL\_LINE\_LOOP}, però en comptes de crear línies crear un polígon.
\end{itemize}
Podem veure exemples de les 10 primitives a la figura \ref{fig: primitives}

\begin{figure}
\centering
\includegraphics{images/primitives.png}
\caption{Primitives gràfiques d'OpenGL}
\label{fig: primitives}
\end{figure}


\subsection{Paradigmes de navegació 3D}
\paragraph{}
La navegació d'escenes 3D té tres paradigmes fonamentals, Walk, Fly i Examine. Tota aplicació 3D implementa un d'aquests paradigmes, encara que no n'ha d'implementar només un.

\subsubsection{Paradigma walk}
Al paradigma walk, l'usuari del programa pot moure la càmara i per tant navegar per l'escena. L'usuari sol estar representat per una entitat dins de l'escena anomenada avatar. L'avatar està sotmés a la gravetat i per tant només pot caminar per superfícies planes, pujar pendents poc pronunciades i xoca contra les parets. Els moviments típics de l'avatar són desplaçar-se en qualsevol de les quatre direccions (endavant, endarrera, esquerra i dreta) i gir de la càmara per enfocar cap a qualsevol direcció possible. En aquest paradigma la visió pot ser en primera persona o en tercera persona. A la visió primera persona, la càmara es situa als ulls de l'avatar, veient-se allò que veuria l'avatar, per tant, de l'avatar només es sol veure les mans i peus. A la visió en tercera persona la càmara es situa fora de l'avatar, normalment per darrera d'ell, de forma que ens permet veure la situació de l'avatar d'una manera més global. Aquesta càmara té més problemes de gestió, ja que s'ha d'anar amb compte de que la càmara no atravesi parets quan l'avatar s'apropa a elles, ja que si ho fes no veuriem l'avatar, sinó la paret. A més a més la visió en primera persona sol donar més sensació d'inmersió, per tant la majoria de programes 3D que utilitzen el paradigma walk solen optar per ella.

\subsubsection{Paradigma fly}
El paradigma fly és gairabé igual al paradigma walk, sent la no existència de la gravetat la diferència més gran. El paradigma fly se sol utilitzar en simuladors espaials o bé en els mateixos escenaris que utilitzen el paradigma walk per donar-li a l'usuari més llibertat a l'hora de reconèixer l'escena, per exemple es molt possible que als dissenyadors de pantalles els interesi poder volar per l'escenari per així poder desplaçar-se entre diferents alçades de forma més ràpida. Així mateix a vegades el paradigma fly desactiva la detecció de col·lisions permetent que l'avatar atravesi les parets.

\subsubsection{Paradigma examine}


\subsection{Representació interactiva de superfícies en 3D}
\paragraph{}
La representació de interactiva superfícies en 3D tracta de com aconseguir malles de triangles que representin una superfície 3D tant de forma acurada com de forma eficient. La eficiència ve donada per la interactivitat, ja que com s'ha comentat anteriorment, els gràfics interactius necesiten acualitzar la imatge vàries vegades per segon. Per aconseguir tots dos objectius, que en principi es contradiuen, el que fan la majoria d'algorismes és generar una malla de triangles potencialment diferent per cada posició de l'observador. D'aquesta manera s'intenta generar una malla de triangles que sigui la òptima per aquesta posició, on òptima significa ser el més acurada possible per allò que és aprop de l'observador i alhora suficientment ràpida per poder-se visualitzar de forma interactiva.

\subsection{L'algorisme ROAM}

\subsection{El format DEM}
\paragraph{}
El format DEM\footnote{Especificació: http://rockyweb.cr.usgs.gov/nmpstds/acrodocs/dem/2DEM0198.PDF} (Digital Elevation Model) va ser creat per l'USGS \textit{(United States Geological Survey)} per guardar la informació de les seves mesures de la superfície dels Estats Units.
\paragraph{}
Un fitxer DEM està organitzat en tres tipus de registres lògics: A, B i C. 
\begin{itemize}
\item El tipus de registre A conté informació en quant les característiques generals del mapa, nom, límits, unitats de mesura, elevació mínima i màxima, el número de registres de tipus B, etc. Només hi ha un registre de tipus A per fitxer.
\item Els registres de tipus B contenen la informació de les alçades propiament dita.
\item El tipus de registre C conté estàdistiques en quant a l'exactitud de les dades del fitxer.
\end{itemize}
\paragraph{}
Degut a que el format DEM estava pensat per emmagatzemar-se en cintes magnètiques, l'especificació del format parla de registres físics, cadascun de 1024 bytes. En un registre físic no hi pot haver més d'un registre lògic, en canvi és usual que els registres lògics de tipus B ocupin més d'un registre lògic. Les parts d'un registre físic no ocupades per la informació d'un registre lògic s'han d'omplir amb blancs. Els registres lògics de tipus A i C mai ocupen més d'un registre físic.
\paragraph{}
Els fitxers DEM divideixen el mapa en una graella i proporcionen l'alçada de cadascun dels punts de la graella. Cada registre de tipus B té la informació de les alçades d'una columna d'aquesta graella, es a dir, si la graella d'un mapa tinguès n columnes i m files hi hauria n registres de tipus B cadascun amb m alçades.
\paragraph{}
Hi ha tres tipus de fitxers DEM:
\begin{enumerate}
\item \textbf{DEM d'1 grau:} Tenen 1201*1201 punts de dades, estan basats en latitud-longitud i l'espaiat entre els punts de la graella és de 3 segons d'arc, que és aproximadament 90 metres, encara que obviament depèn de la latitud.
\item \textbf{DEM de 30 minuts:} Són 4 unitats de fitxers DEM d'1 grau distribuïdes de forma conjunta, són el menys comú dels 3 tipus.
\item \textbf{DEM de 7.5 minuts:} L'espaiat entre els punts de la graella pot ser de 30 o 10 metres (1 segon d'arc i 1/3 de segon d'arc respectivament), els límits del fitxer estan basats en latitud-longitud, però en canvi els punts de dades es donen en coordenada x-y d'una projecció Mercator, resultant en fitxers on no tots registres de tipus B tenen la mateixa longitud. (Figura \ref{fig: dem})
\end{enumerate}

\begin{figure}
\centering
\includegraphics{images/dem75.png}
\caption{Esquema d'un DEM de 7.5 minuts}
\label{fig: dem}
\end{figure}

\subsection{GPL}
\paragraph{}
GPL (\textbf{G}eneral \textbf{P}ublic \textbf{L}icense) és una llicència de software lliure. La llicència GPL garanteix als destinataris d'un programa informàtic els següents drets o llibertats:
\begin{itemize}
\item La llibertat per executar el programa sigui quin sigui el propòsit
\item La llibertat d'estudiar com funciona el programa i de modificar-lo (Evidentment cal tenir accés al codi com a precondició per complir això)
\item La llibertat de distribuir copies (ja siguin modificades o sense modificar)
\end{itemize}
\paragraph{}
La llicència GPL és una de les llicències de software lliure més exteses, si visitem la pàgina de SourceForge (una pàgina web on es registren projectes de software lliure per tal de desenvolupar-los usant les serveis que aquesta proporciona) que llista el número de projectes registrats per cada tipus de llicència, veiem que un 69\% (43089 dels 62291) utilitzen la llicència GPL.
\paragraph{}
Es pot trobar el text complet de la llicència a \textit{http://www.gnu.org/licenses/gpl.html}
\subsection{Qt}
\paragraph{}
Qt és un \textit{framework} complet de desenvolupament d'aplicacions en C++. Inclou una llibreria així com eines per la internacionalització i el desenvolupament multiplataforma d'aplicacions.
\paragraph{}
Qt aconsegueix ser multiplataforma abstraient els sistemes operatius i de gestió de finestres, de forma que proporciona una API coherent, lògica i orientada a objectes comú. Les aplicacions Qt s'executen nativament, compilades des del mateix codi font, a totes les plataformes suportades:
\begin{itemize}
\item Qt/Windows (Microsoft Windows XP, 2000, NT 4, Me/98/95)
\item Qt/X11 (Linux, Solaris, HP-UX, IRIX, AIX, i altres variants Unix)
\item Qt/Mac (Mac OS X)
\item Qt/Embedded (Linux embedded)
\end{itemize}
\paragraph{}
La llibreria inclou una gran part de classes per a la construcció d'interfícies gràfiques, encara que també proporciona moltes altres funcionalitats, com comunicació per xarxa via sockets, classes per treballar amb XML, classes per accedir a fitxers, etc.
\paragraph{}
Qt té un sistema de llicències dual que permet desenvolupar tant aplicacions lliures (sota la llicència GPL) com aplicacions propietàries. Actualment, aquest sistema està disponible per totes les plataformes excepte per a Qt/Windows, però la versió Qt 4.0, esperada per finals del segon quatrimestre del 2005, també usarà aquest sistema.

\newpage
\section{Especificació}
\subsection{Què és r3v?}
\subsection{Què és libroam?}
\subsection{Requeriments no funcionals}
\subsection{Requeriments funcionals}
\subsection{Model Conceptual}
\subsubsection{Restriccions d'integritat}
\subsection{Model de casos d'ús}

\begin{figure}
\centering
\includegraphics{images/casosUs.png}
\caption{Diagrama de casos d'ús}
\label{fig: casosUs}
\end{figure}

\paragraph{}
Com es pot veure a la figura \ref{fig: casosUs} l'aplicació $r3v$ disposa d'un petit número de casos d'ús.

\newpage
\section{Disseny}

\subsection{Arbres binaris de triangles}
\paragraph{}
Un arbre binari de triangles és un arbre per organitzar triangles de forma jeràrquica. El triangle arrel $T = (v_a, v_0, v_1)$ és un triangle isòsceles amb àpex $v_a$. Els fills de l'arrel es defineixen partint l'arrel en dos parts fent crent una nova aresta que va des del vèrtex $v_a$ al punt mig $v_c$ de l'aresta base (aresta entre $v_0$ i $v_1$). El fill esquerre de $T$ és $T_0 = (v_c, v_a, v_0)$ mentre que el fill dret és $T_1 = (v_c, v_1, v_a)$. La resta de de l'estructura de l'arbre de triangles és una repetició recursiva del procés de partició explicat anteriorment. Dins de l'arbre cada triangle té un nivell $l$ definit pel nombre de vegades que s'ha partit al triangle arrel per arribar a generar aquell triangle en concret. A la figura \ref{fig: triangles} podem veure una representació dels nivells 0 a 5 d'un arbre binari de triangles.

\begin{figure}
\centering
\includegraphics{images/triangles.png}
\caption{Representació dels nivells 0 a 5 d'un arbre binari de triangles}
\label{fig: triangles}
\end{figure}

\subsubsection{Representació de superfícies amb arbres binaris}
\paragraph{}
Per representar una superfície amb arbres binaris de triangles es fan servir dos arbres de triangles situats de forma que comparteixin la seva aresta base, d'aquesta forma es cubreix una superfície quadrada (Figura \ref{fig: diamant}). Un cop tenim una estructura que permet cubrir tot un quadrat només cal assignar a cada vèrtex una alçada $w(v)$ per tenir una forma eficient de guardar les alçades d'un terreny.

\begin{figure}
\centering
\includegraphics{images/diamant.png}
\caption{Dos arbres de triangles serveixen per representar una superfície quadrada}
\label{fig: diamant}
\end{figure}

\subsubsection{Conjunts d'arbres binaris de triangles}
\paragraph{}
Una a triangulació d'arbres binaris de triangles (triangulació d'ara en endavant) és un conjunt d'arbres binaris que tenen alguna relació de veïnatge entre ells, ja sigui compartint un vèrtex o una aresta. Un cas especial de triangulació és el diamant, triangulació format per dos triangles que comparteixen l'aresta base i tenen el mateix nivell, la figura \ref{fig: diamant} és un exemple de diamant. Un fet important d'una triangulació és que donat un triangle, el triangle amb el que comparteix la base és del mateix nivell o del nivell superior. A la figura \ref{fig: triangleBase} podem veure un exemple de les dues situacions, el triangle A comparteix la base amb un triangle del seu nivell mentre que el triangle B comparteix la base amb un triangle d'un nivell superior ($l$ més petita).

\begin{figure}
\centering
\includegraphics{images/triangleBase.png}
\caption{Possibilitats de compartir la base}
\label{fig: triangleBase}
\end{figure}

\subsubsection{Operacions sobre diamants}
\paragraph{}
Sobre un diamant es poden realitzar dues operacions, split i merge. Split (partir) consisteix en crear els fills de $T$ i del seu triangle base $T_B$ de forma que s'obté una triangulació formada pels triangles $T_1$, $T_2$, $T_B1$ i $T_B2$. Merge (fusionar) consisteix en tornar als triangles $T$ i $T_B$ a partir dels seus quatre fills. Es pot veure una representació dels processos de partició i unió a la figura \ref{fig: splitMerge}.

\begin{figure}
\centering
\includegraphics{images/splitMerge.png}
\caption{Split i merge sobre una triangulació}
\label{fig: splitMerge}
\end{figure}

\paragraph{}
Només els triangles que tenen el mateix nivell que el triangle amb el que comparteixen la base són susceptibles de ser partits. Aquells que comparteixen la base amb un triangle de nivell superior ($l$ més petita) (per exemple el triangle B de la figura \ref{fig: triangleBase})  no poden ser partits directament i si realment volem partir-los hem de fer abans un split del triangle amb el que comparteix la base. La figura \ref{fig: forceSplitExtrem} és un cas extrem en el que caldria fer 4 splits forçats abans de fer la partició del triangle $T$.

\begin{figure}
\centering
\includegraphics{images/forceSplitExtrem.png}
\caption{Cas extrem en el que cal aplicar 4 particions forçades}
\label{fig: forceSplitExtrem}
\end{figure}

\paragraph{}
En primera instància es pot pensar que no seria necessari que l'operació de split s'apliquès sobre un diamant i que es podria fer sobre un triangle sol, però això no es possible ja que crearia una discontinuitat en la superfície. A la figura \ref{fig: discontinuitat} veiem la representació resultant de partir només un dels triangles del diamant d'una superfície en la que els punts $(0, 0)$, $(0, 1)$, $(1, 0)$ i $(1, 1)$ tenen una alçada de 0 mentre que el punt $(0.5, 0.5)$ té una alçada de 1.

\begin{figure}
\centering
\includegraphics{images/discontinuitat.png}
\caption{Discontinuitat: Resultat de partir un triangle i no un diamant}
\label{fig: discontinuitat}
\end{figure}

\subsection{Escala de colors}
\paragraph{}

\newpage
\section{Implementació}

\subsection{Generació de Makefiles}
\paragraph{}
Qt té la seva pròpia eina per la generació automàtica de Makefiles anomenada Qt, però com ja s'ha comentat no volem que el programa depengui de Qt, per tant, hi havia dos opcions, la creació manual dels Makefiles o usar un generador automàtic de Makefiles que sigui \textit{neutre}. La creació manual de Makefiles va quedar descartada ràpidament, ja que era una opció més pesada i menys potent, per tant s'havia de decidir quin generador automàtic usar. Aquesta decisió tampoc va ser gaire complicada, ja que encara que hi ha una varies eines que poden fer aquesta tasca, autotools és la més comú i es pot trobar a quasi totes les distribucions de Linux i a també funciona a quasi tots els Unix.

\subsection{Autotools}
\paragraph{}
Encara que sovient es parla d'Autotools (tal i com es farà en aquest document), Autotools és en realitat un paraula utilitzada per referir-se a un conjunt d'eines el nom de les quals comença per auto-, com autoheader, automake i autoconf. La sintaxi dels fitxers utilitzats per les autotools pot semblar complicada inicialment però si ens limitem a fer coses simples com les que fa aquest projecte (compilar una llibreria i un ejecutable que depèn d'ella) es força potent i fàcil de fer servir.

\paragraph{}
Autoconf és l'eina que serveix per comprovar que la plataforma en la que es compilarà el programa té les eines i llibreries que calen. A part, també serveix per detectar particularitats de la plataforma, per exemple si en aquesta plataforma una funció te uns paràmetres no estàndard, i definir uns símbols que més tard farem servir en el codi font per adaptar-nos a totes les plataformes. Per part del programador només s'ha de crear el fitxer configure.in que conté paraules clau que indiquen totes les comprovacions que volem fer, a partir d'aquest fitxer, autoconf genera un script anomenat configure que en executar-se en l'ordinador que està compilant el programa fa les comprovacions i avisa en cas de que alguna condició no és compleixi.

\paragraph{}
Per aquest projecte el fitxer configure.in es limita a comprovar l'existència d'un compilador de C++, que l'eina libtool es trobi instal·lada al sistema i finalment fa la comprovació de si Qt està instal·lat. En el cas de Qt es comprova si la versió instal·lada és 3.x o 4.0 i es defineix el simbol Qt4 de forma que el programa funcioni tant amb les versions 3.x com amb la versió 4.0 (que com s'ha esmentat anteriorment encara no té versió final, però ja hi ha versions preliminars suficientment funcionals per compilar aquest projecte).

\paragraph{}
Automake és l'eina que serveix per generar els Makefile. De forma ràpida un Makefile és un fitxer que indica com s'ha de compilar un programa i la depèndencia dels fitxers entre si, de forma que en canviar un fitxer es tornin a recompilar només aquells que tenen alguna relació. Aquesta eina genera fitxers Makefile.in a partir de fitxers Makefile.am, els fitxers Makefile.in es converteixen en fitxers Makefile al executar-se el configure creat per Autoconf. Als fitxers Makefile.am només cal indicar quines són les llibreries i els fitxers de codi font que utilitza en nostre programa/libreria i Automake s'encarrega de generar un Makefile complet amb els típics install, clean, uninstall, etc.

\paragraph{}
Per aquest projecte hem utilitzat fitxers Makefile.am per generar la llibreria libroam i per generar l'executable r3v, les opcions usades han estat bastant simples, al fitxer Makefile.am de libroam s'ha indicat que volem que sigui una llibreria estàtica generada per libtool formada per tots els fitxers .cpp del directori i a més a més usant les llibreries GL i GLU. Per a l'executable r3v, s'ha indicat que es volia generar un executable usant el codi de la interfície en Qt i usant la llibreria libtool així com la llibreria Qt.

\paragraph{}
L'ús de les autotools presenta un \textit{petit problema} en quant a la portabilitat del projecte, ja que no hi ha versió nativa de les autotools per a Windows. Això significa que el projecte no pot ser compilat directament sota Windows, cal adaptar-lo a les eines del compilador de C++ que s'usi; un petit problema de portabilitat però que no afecta de cap manera que el codi del programa continui sent portable.

\subsection{Lector de format DEM}

\paragraph{}

\newpage
\section{Recursos i Anàlisi de costos}
\subsection{Recursos humans i tecnològics}
\subsection{Anàlisi de costos}
\newpage
\section{Conclusions}
\newpage
\section{Bibliografia}
\newpage
\section{Index de figures}
\listoffigures
\end{document}
