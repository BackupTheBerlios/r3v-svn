Index: libroam/roam.cpp
===================================================================
--- libroam/roam.cpp	(revision 119)
+++ libroam/roam.cpp	(working copy)
@@ -82,6 +82,8 @@
 	
 
 	frustum f = getFrustum();
+	f.setTriangleStatus(d -> t1());
+	f.setTriangleStatus(d -> t2());
 	d -> t1() -> calcPriority(f);
 	d -> t2() -> calcPriority(f);
 	m_splitQueue -> insert(d -> t1());
@@ -117,53 +119,61 @@
 	
 	frustum f = getFrustum();
 	
-// 	newSplitQueue = new triangleList();
-// 	sqEndIt = m_splitQueue -> end();
-// 	for (sqIt = m_splitQueue -> begin(); sqIt != sqEndIt; ++sqIt)
-// 	{
-// 		t = (*sqIt).second;
-// 		t -> calcPriority(f);
-// 		newSplitQueue->insert(t);
-// 	}
-// // 	printf("%d %d\n", m_splitQueue->count(), newSplitQueue->count());
-// 	delete m_splitQueue;
-// 	m_splitQueue = newSplitQueue;
-// 	
-// 	newMergeQueue = new diamondList();
-// 	mqEndIt = m_mergeQueue -> end();
-// 	for (mqIt = m_mergeQueue -> begin(); mqIt != mqEndIt; ++mqIt)
-// 	{
-// 		d = (*mqIt).second;
-// 		d -> t1() -> calcPriority(f);
-// 		d -> t2() -> calcPriority(f);
-// 		newMergeQueue->insert(d);
-// 	}
-// // 	printf("%d %d\n", m_mergeQueue->count(), newMergeQueue->count());
-// 	delete m_mergeQueue;
-// 	m_mergeQueue = newMergeQueue;
-// 	
-// 	bool b = true;
-// 	while (m_map -> leaves() < 5000 ||
-// 	       (m_mergeQueue -> count() &&
-// 	       m_splitQueue -> last() -> priority() > m_mergeQueue -> first() -> priority()))
-// 	{
-// 		if (b) printf("ENTRAMOS\n");
-// 		b = false;
-// 		if (m_mergeQueue -> count()) printf("A partir: %f A fusionar: %f\n", m_splitQueue -> last() -> priority(), m_mergeQueue -> first() -> priority());
-// 		if (m_map -> leaves() < 5000)
-// 		{
-// 			printf("Partimos\n");
-// 			t = m_splitQueue -> last();
-// 			t -> split(m_splitQueue, m_mergeQueue, f);
-// 		}
-// 		else
-// 		{
-// 			printf("Fusionamos\n");
-// 			d = m_mergeQueue -> first();
-// 			d -> merge(m_splitQueue, m_mergeQueue);
-// 		}
-// 	}
+	d = m_map -> baseDiamond();
+	f.setTriangleStatus(d -> t1());
+	f.setTriangleStatus(d -> t2());
+	
+	newSplitQueue = new triangleList();
+	sqEndIt = m_splitQueue -> end();
+	for (sqIt = m_splitQueue -> begin(); sqIt != sqEndIt; ++sqIt)
+	{
+		t = (*sqIt).second;
+		t -> calcPriority(f);
+		newSplitQueue->insert(t);
+	}
+// 	printf("%d %d\n", m_splitQueue->count(), newSplitQueue->count());
+	delete m_splitQueue;
+	m_splitQueue = newSplitQueue;
+	
+	newMergeQueue = new diamondList();
+	mqEndIt = m_mergeQueue -> end();
+	for (mqIt = m_mergeQueue -> begin(); mqIt != mqEndIt; ++mqIt)
+	{
+		d = (*mqIt).second;
+		d -> t1() -> calcPriority(f);
+		d -> t2() -> calcPriority(f);
+		newMergeQueue->insert(d);
+	}
+// 	printf("%d %d\n", m_mergeQueue->count(), newMergeQueue->count());
+	delete m_mergeQueue;
+	m_mergeQueue = newMergeQueue;
+	
+	printf("%d\n", m_mergeQueue -> count());
+	
+	bool b = true;
+	while (m_map -> leaves() < 5000 ||
+	       (m_mergeQueue -> count() &&
+	       m_splitQueue -> last() -> priority() > m_mergeQueue -> first() -> priority()))
+	{
+		if (b) printf("ENTRAMOS\n");
+		b = false;
+		if (m_mergeQueue -> count()) printf("A partir: %f A fusionar: %f\n", m_splitQueue -> last() -> priority(), m_mergeQueue -> first() -> priority());
+		if (m_map -> leaves() < 5000)
+		{
+			printf("Partimos\n");
+			t = m_splitQueue -> last();
+			t -> split(m_splitQueue, m_mergeQueue, f);
+		}
+		else
+		{
+			printf("Fusionamos\n");
+			d = m_mergeQueue -> first();
+			d -> merge(m_splitQueue, m_mergeQueue);
+		}
+	}
 
+// 	renew();
+
 	glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
 	glBegin(GL_TRIANGLES);
 	paintTriangle(m_map -> baseDiamond() -> t1(), false);
@@ -222,9 +232,8 @@
 void ROAM::splitOne()
 {
 	triangle *t;
-	frustum f = getFrustum();
 	t = m_splitQueue->last();
-	t -> split(m_splitQueue, m_mergeQueue, f);
+	t -> split(m_splitQueue, m_mergeQueue, getFrustum());
 }
 
 void ROAM::mergeOne()
@@ -234,34 +243,34 @@
 	d -> merge(m_splitQueue, m_mergeQueue);
 }
 
-void ROAM::renew()
-{
-	diamond *d = m_map -> baseDiamond();
-	
-	d->t1()->deleteLeaves(m_splitQueue);
-	d->t2()->deleteLeaves(m_splitQueue);
+// void ROAM::renew()
+// {
+// 	diamond *d = m_map -> baseDiamond();
+// 	
+// 	d->t1()->deleteLeaves(m_splitQueue);
+// 	d->t2()->deleteLeaves(m_splitQueue);
+// 
+// 	delete m_splitQueue;
+// 	delete m_mergeQueue;
+// 	
+// 	m_splitQueue = new triangleList();
+// 	m_mergeQueue = new diamondList();
+// 	
+// 	frustum f = getFrustum();
+// 	
+// 	d -> t1() -> calcPriority(f);
+// 	d -> t2() -> calcPriority(f);
+// 	m_splitQueue -> insert(d -> t1());
+// 	m_splitQueue -> insert(d -> t2());
+// 	
+// 	triangle *t;
+// 	for (int kk = 0; kk < 500; kk++)
+// 	{
+// 		t = m_splitQueue -> last();
+// 		t -> split(m_splitQueue, m_mergeQueue, f);
+// 	}
+// }
 
-	delete m_splitQueue;
-	delete m_mergeQueue;
-	
-	m_splitQueue = new triangleList();
-	m_mergeQueue = new diamondList();
-	
-	frustum f = getFrustum();
-	
-	d -> t1() -> calcPriority(f);
-	d -> t2() -> calcPriority(f);
-	m_splitQueue -> insert(d -> t1());
-	m_splitQueue -> insert(d -> t2());
-	
-	triangle *t;
-	for (int kk = 0; kk < 500; kk++)
-	{
-		t = m_splitQueue -> last();
-		t -> split(m_splitQueue, m_mergeQueue, f);
-	}
-}
-
 frustum ROAM::getFrustum() const
 {
 	double modelViewMatrix[16], projectionMatrix[16];
@@ -274,8 +283,8 @@
 {
 	if (t -> isLeaf())
 	{
-		if (t -> isVisible())
-		{
+// 		if (t -> isVisible())
+// 		{
 			node *nodes[3];
 			nodes[0] = t -> apex();
 			nodes[1] = t -> rightVertex();
@@ -290,7 +299,7 @@
 				
 				glVertex3dv(nodes[i] -> coords());
 			}
-		}
+// 		}
 	}
 	else
 	{
Index: libroam/roam.h
===================================================================
--- libroam/roam.h	(revision 119)
+++ libroam/roam.h	(working copy)
@@ -44,7 +44,7 @@
 		void mergeOne();
 		void splitOne();
 		
-		void renew();
+// 		void renew();
 		
 	private:
 		void clean();
Index: libroam/frustum.cpp
===================================================================
--- libroam/frustum.cpp	(revision 119)
+++ libroam/frustum.cpp	(working copy)
@@ -96,7 +96,7 @@
 	else
 	{
 		int count = 0;
-		for (p = 0; p < 6; p++)
+		for (p = 0; p < 4; p++)
 		{
 			int aux = 0;
 			
@@ -119,7 +119,7 @@
 			}
 		}
 		
-		if (count == 6)
+		if (count == 4)
 		{
 			// All three points are in front of all the planes
 			s = triangle::COMPLETELYINSIDE;
Index: libroam/triangle.cpp
===================================================================
--- libroam/triangle.cpp	(revision 119)
+++ libroam/triangle.cpp	(working copy)
@@ -82,6 +82,7 @@
 		delete m_rightTriangle;
 		m_rightTriangle = 0;
 		m_map.addLeaves(1);
+		updateWedgie();
 	}
 }
 
@@ -122,7 +123,8 @@
 
 void triangle::updateWedgie()
 {
-	m_wedgie = m_ownWedgie + std::max(m_leftTriangle -> m_wedgie, m_rightTriangle -> m_wedgie);
+	m_wedgie = m_ownWedgie;
+	if (m_leftTriangle) m_wedgie += std::max(m_leftTriangle -> m_wedgie, m_rightTriangle -> m_wedgie);
 	if (m_parentTriangle) m_parentTriangle -> updateWedgie();
 }
 
@@ -154,6 +156,8 @@
 	// TODO place in other function?
 	m_map.addTriangles(2);
 	m_map.addLeaves(1);
+	f.setTriangleStatus(m_leftTriangle);
+	f.setTriangleStatus(m_rightTriangle);
 	m_leftTriangle -> calcPriority(f);
 	m_rightTriangle -> calcPriority(f);
 	splitQueue->insert(m_leftTriangle);
@@ -162,6 +166,9 @@
 	// baseTriangle -> m_leftTriangle to stop recurring splitting between base neighbours
 	if (baseTriangle && !baseTriangle -> m_leftTriangle) baseTriangle -> split(splitQueue, mergeQueue, f);
 	
+	updateWedgie();
+	calcPriority(f);
+	
 	if (m_parentTriangle) m_parentTriangle -> setMergeable(false, mergeQueue, baseTriangle);
 	if (baseTriangle)
 	{
@@ -174,8 +181,6 @@
 			setMergeable(true, mergeQueue, baseTriangle);
 		}
 	}
-	
-	updateWedgie();
 }
 
 double triangle::priority() const
@@ -185,8 +190,8 @@
 
 void triangle::calcPriority(const frustum &f)
 {
-	f.setTriangleStatus(this);
-	
+	assert(m_status != UNKNOWN);
+
 	if (!isVisible())
 	{
 		m_priority = DBL_MIN;
Index: libroam/triangle.h
===================================================================
--- libroam/triangle.h	(revision 119)
+++ libroam/triangle.h	(working copy)
@@ -59,7 +59,7 @@
 		FRUSTUMSTATUS frustumStatus() const;
 		void setFrustumStatus(FRUSTUMSTATUS s);
 	
-	private:
+// 	private:
 		r3vMap &m_map;
 		
 		node *m_apex;
Index: glwidget.cpp
===================================================================
--- glwidget.cpp	(revision 119)
+++ glwidget.cpp	(working copy)
@@ -170,9 +170,9 @@
 			if (m_roam.hasMap()) m_roam.mergeOne();
 		break;
 		
-		case Qt::Key_3:
+/*		case Qt::Key_3:
 			if (m_roam.hasMap()) m_roam.renew();
-		break;
+		break;*/
 		
 // 		case Key_3:
 // 			for (int i = 0; i < 10; i++)
