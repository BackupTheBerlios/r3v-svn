Index: PATCH
===================================================================
--- PATCH	(revision 120)
+++ PATCH	(working copy)
@@ -1,768 +0,0 @@
-Index: PATCH
-===================================================================
---- PATCH	(revision 119)
-+++ PATCH	(working copy)
-@@ -1,393 +0,0 @@
--Index: libroam/roam.cpp
--===================================================================
----- libroam/roam.cpp	(revision 112)
--+++ libroam/roam.cpp	(working copy)
--@@ -11,6 +11,7 @@
-- #include "GL/glu.h"
-- 
-- #include "diamond.h"
--+#include "frustum.h"
-- #include "map.h"
-- #include "node.h"
-- #include "roam.h"
--@@ -79,8 +80,14 @@
-- 	m_splitQueue = new triangleList();
-- 	m_mergeQueue = new diamondList();
-- 	
---	double modelViewMatrix[16];
--+	double modelViewMatrix[16], projectionMatrix[16];
-- 	glGetDoublev(GL_MODELVIEW_MATRIX, modelViewMatrix);
--+	glGetDoublev(GL_PROJECTION_MATRIX, projectionMatrix);
--+	frustum f(projectionMatrix, modelViewMatrix);
--+	
--+	f.setTriangleStatus(d -> t1());
--+	f.setTriangleStatus(d -> t2());
--+	
-- 	d -> t1() -> calcPriority(modelViewMatrix);
-- 	d -> t2() -> calcPriority(modelViewMatrix);
-- 	m_splitQueue -> insert(d -> t1());
--@@ -123,53 +130,55 @@
-- 	
-- 	glGetDoublev(GL_MODELVIEW_MATRIX, modelViewMatrix);
-- 	
---	newSplitQueue = new triangleList();
---	sqEndIt = m_splitQueue -> end();
---	for (sqIt = m_splitQueue -> begin(); sqIt != sqEndIt; ++sqIt)
---	{
---		t = (*sqIt).second;
---		t -> calcPriority(modelViewMatrix);
---		newSplitQueue->insert(t);
---	}
---// 	printf("%d %d\n", m_splitQueue->count(), newSplitQueue->count());
---	delete m_splitQueue;
---	m_splitQueue = newSplitQueue;
---	
---	newMergeQueue = new diamondList();
---	mqEndIt = m_mergeQueue -> end();
---	for (mqIt = m_mergeQueue -> begin(); mqIt != mqEndIt; ++mqIt)
---	{
---		d = (*mqIt).second;
---		d -> t1() -> calcPriority(modelViewMatrix);
---		d -> t2() -> calcPriority(modelViewMatrix);
---		newMergeQueue->insert(d);
---	}
---// 	printf("%d %d\n", m_mergeQueue->count(), newMergeQueue->count());
---	delete m_mergeQueue;
---	m_mergeQueue = newMergeQueue;
---	
---	bool b = true;
---	while (m_map -> leaves() < 5000 ||
---	       (m_mergeQueue -> count() &&
---	       m_splitQueue -> last() -> priority() > m_mergeQueue -> first() -> priority()))
---	{
---		if (b) printf("ENTRAMOS\n");
---		b = false;
---		if (m_mergeQueue -> count()) printf("A partir: %f A fusionar: %f\n", m_splitQueue -> last() -> priority(), m_mergeQueue -> first() -> priority());
---		if (m_map -> leaves() < 5000)
---		{
---			printf("Partimos\n");
---			t = m_splitQueue -> last();
---			t -> split(m_splitQueue, m_mergeQueue, modelViewMatrix);
---		}
---		else
---		{
---			printf("Fusionamos\n");
---			d = m_mergeQueue -> first();
---			d -> merge(m_splitQueue, m_mergeQueue);
---		}
---	}
--+// 	newSplitQueue = new triangleList();
--+// 	sqEndIt = m_splitQueue -> end();
--+// 	for (sqIt = m_splitQueue -> begin(); sqIt != sqEndIt; ++sqIt)
--+// 	{
--+// 		t = (*sqIt).second;
--+// 		t -> calcPriority(modelViewMatrix);
--+// 		newSplitQueue->insert(t);
--+// 	}
--+// // 	printf("%d %d\n", m_splitQueue->count(), newSplitQueue->count());
--+// 	delete m_splitQueue;
--+// 	m_splitQueue = newSplitQueue;
--+// 	
--+// 	newMergeQueue = new diamondList();
--+// 	mqEndIt = m_mergeQueue -> end();
--+// 	for (mqIt = m_mergeQueue -> begin(); mqIt != mqEndIt; ++mqIt)
--+// 	{
--+// 		d = (*mqIt).second;
--+// 		d -> t1() -> calcPriority(modelViewMatrix);
--+// 		d -> t2() -> calcPriority(modelViewMatrix);
--+// 		newMergeQueue->insert(d);
--+// 	}
--+// // 	printf("%d %d\n", m_mergeQueue->count(), newMergeQueue->count());
--+// 	delete m_mergeQueue;
--+// 	m_mergeQueue = newMergeQueue;
--+// 	
--+// 	bool b = true;
--+// 	while (m_map -> leaves() < 5000 ||
--+// 	       (m_mergeQueue -> count() &&
--+// 	       m_splitQueue -> last() -> priority() > m_mergeQueue -> first() -> priority()))
--+// 	{
--+// 		if (b) printf("ENTRAMOS\n");
--+// 		b = false;
--+// 		if (m_mergeQueue -> count()) printf("A partir: %f A fusionar: %f\n", m_splitQueue -> last() -> priority(), m_mergeQueue -> first() -> priority());
--+// 		if (m_map -> leaves() < 5000)
--+// 		{
--+// 			printf("Partimos\n");
--+// 			t = m_splitQueue -> last();
--+// 			t -> split(m_splitQueue, m_mergeQueue, modelViewMatrix);
--+// 		}
--+// 		else
--+// 		{
--+// 			printf("Fusionamos\n");
--+// 			d = m_mergeQueue -> first();
--+// 			d -> merge(m_splitQueue, m_mergeQueue);
--+// 		}
--+// 	}
-- 
--+// 	renew();
--+
-- 	glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
-- 	glBegin(GL_TRIANGLES);
-- 	paintTriangle(m_map -> baseDiamond() -> t1(), false);
--@@ -241,11 +250,45 @@
-- 	d -> merge(m_splitQueue, m_mergeQueue);
-- }
-- 
--+void ROAM::renew()
--+{
--+	diamond *d = m_map -> baseDiamond();
--+	
--+	d->t1()->deleteLeaves(m_splitQueue);
--+	d->t2()->deleteLeaves(m_splitQueue);
--+
--+	delete m_splitQueue;
--+	delete m_mergeQueue;
--+	
--+	m_splitQueue = new triangleList();
--+	m_mergeQueue = new diamondList();
--+	
--+	double modelViewMatrix[16], projectionMatrix[16];
--+	glGetDoublev(GL_MODELVIEW_MATRIX, modelViewMatrix);
--+	glGetDoublev(GL_PROJECTION_MATRIX, projectionMatrix);
--+	frustum f(projectionMatrix, modelViewMatrix);
--+	
--+	f.setTriangleStatus(d -> t1());
--+	f.setTriangleStatus(d -> t2());
--+	
--+	d -> t1() -> calcPriority(modelViewMatrix);
--+	d -> t2() -> calcPriority(modelViewMatrix);
--+	m_splitQueue -> insert(d -> t1());
--+	m_splitQueue -> insert(d -> t2());
--+	
--+	triangle *t;
--+	for (int kk = 0; kk < 500; kk++)
--+	{
--+		t = m_splitQueue -> last();
--+		t -> split(m_splitQueue, m_mergeQueue, modelViewMatrix);
--+	}
--+}
--+
-- void ROAM::paintTriangle(const triangle *t, bool color) const
-- {
---	if (t -> isLeaf())
--+	if (t -> isVisible())
-- 	{
---		if (t -> isVisible())
--+		if (t -> isLeaf())
-- 		{
-- 			node *nodes[3];
-- 			nodes[0] = t -> apex();
--@@ -262,10 +305,10 @@
-- 				glVertex3dv(nodes[i] -> coords());
-- 			}
-- 		}
--+		else
--+		{
--+			paintTriangle(t -> leftTriangle(), color);
--+			paintTriangle(t -> rightTriangle(), color);
--+		}
-- 	}
---	else
---	{
---		paintTriangle(t -> leftTriangle(), color);
---		paintTriangle(t -> rightTriangle(), color);
---	}
-- }
--Index: libroam/roam.h
--===================================================================
----- libroam/roam.h	(revision 106)
--+++ libroam/roam.h	(working copy)
--@@ -42,8 +42,9 @@
-- 		
-- 		void mergeOne();
-- 		void splitOne();
--+		void renew();
-- 		
---	private:
--+// 	private:
-- 		void clean();
-- 		void paintTriangle(const triangle *t, bool color) const;
-- 		
--Index: libroam/triangle.cpp
--===================================================================
----- libroam/triangle.cpp	(revision 111)
--+++ libroam/triangle.cpp	(working copy)
--@@ -72,14 +72,16 @@
-- 
-- void triangle::deleteLeaves(triangleList *splitQueue)
-- {
---// 	printf("%d\n", m_leftTriangle->m_level);
---	splitQueue -> remove(m_leftTriangle);
---	delete m_leftTriangle;
---	m_leftTriangle = 0;
---	splitQueue -> remove(m_rightTriangle);
---	delete m_rightTriangle;
---	m_rightTriangle = 0;
---	m_map.addLeaves(1);
--+	if (m_leftTriangle)
--+	{
--+		splitQueue -> remove(m_leftTriangle);
--+		delete m_leftTriangle;
--+		m_leftTriangle = 0;
--+		splitQueue -> remove(m_rightTriangle);
--+		delete m_rightTriangle;
--+		m_rightTriangle = 0;
--+		m_map.addLeaves(1);
--+	}
-- }
-- 
-- node *triangle::apex() const
--@@ -127,6 +129,7 @@
-- {
-- // 	assert(!m_leftTriangle);
-- // 	assert(!m_rightTriangle);
--+	printf("Prioridad al hacer split %.50f\n", m_priority);
-- 	
-- 	splitQueue->remove(this);
-- 	
--@@ -144,20 +147,11 @@
-- 	y = (m_leftVertex -> getZ() + m_rightVertex -> getZ()) / 2;
-- 	
-- 	node *newApex = m_map.getNode(x, y);
--+	printf("%f %f %f\n", m_leftVertex -> getX(), m_rightVertex -> getX(), x);
--+	printf("%f %f %f\n", m_leftVertex -> getZ(), m_rightVertex -> getZ(), y);
--+	printf("%f\n", m_wedgie);
-- 	
---	/*
---	if (*newApex == *m_leftVertex)
---	{
---		printf("1\n");
---	}
---	else if (*m_apex == *newApex)
---	{
---		printf("2\n");
---	}
---	else if (*m_rightVertex == *m_leftVertex)
---	{
---		printf("3\n");
---	}*/
--+	printf("%d %d %d %d\n", *newApex == *m_leftVertex, *m_apex == *newApex, *m_rightVertex == *m_leftVertex, *newApex == *m_rightVertex);
-- 	
-- 	m_leftTriangle = new triangle(m_map, newApex, m_apex, m_leftVertex, this);
-- 	m_rightTriangle = new triangle(m_map, newApex, m_rightVertex, m_apex, this);
--@@ -175,11 +169,16 @@
-- 	if (m_parentTriangle) m_parentTriangle -> setMergeable(false, mergeQueue, baseTriangle);
-- 	if (baseTriangle)
-- 	{
--+		assert(m_leftTriangle -> isLeaf());
--+		assert(m_rightTriangle -> isLeaf());
--+// 		printf("%lx %lx %d\n", baseTriangle, baseTriangle -> m_leftTriangle, baseTriangle -> m_leftTriangle -> isLeaf());
--+		assert(baseTriangle -> m_leftTriangle -> isLeaf());
--+		assert(baseTriangle -> m_rightTriangle -> isLeaf());
-- 		if (m_leftTriangle -> isLeaf() && m_rightTriangle -> isLeaf() && baseTriangle -> m_leftTriangle -> isLeaf() && baseTriangle -> m_rightTriangle -> isLeaf())
-- 		{
-- 			setMergeable(true, mergeQueue, baseTriangle);
-- 		}
---		else printf("NO PASA NUNCA\n");
--+// 		else printf("%d %d %d %d\n", m_leftTriangle -> isLeaf(), m_rightTriangle -> isLeaf(), baseTriangle -> m_leftTriangle -> isLeaf(), baseTriangle -> m_rightTriangle -> isLeaf());
-- 	}
-- 	
-- 	updateWedgie();
--@@ -194,6 +193,15 @@
-- {
-- // 	qDebug("%f %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f", modelViewMatrix[0], modelViewMatrix[1], modelViewMatrix[2], modelViewMatrix[3], modelViewMatrix[4], modelViewMatrix[5], modelViewMatrix[6], modelViewMatrix[7], modelViewMatrix[8], modelViewMatrix[9], modelViewMatrix[10], modelViewMatrix[11], modelViewMatrix[12], modelViewMatrix[13], modelViewMatrix[14], modelViewMatrix[15]);
-- 
--+// 	assert(m_status != UNKNOWN);
--+
--+	printf("CP WEDGIE %.50f\n", m_wedgie);
--+	if (m_wedgie < 0.05)
--+	{
--+		m_priority = 0;
--+// 		return;
--+	}
--+
-- 	double a, b, c, p1, q1, r1, p2, q2, r2, p3, q3, r3, d1, d2, d3, csq, r1sq, r2sq, r3sq;
-- 	a = modelViewMatrix[0] * 0.0 + modelViewMatrix[4] * m_wedgie + modelViewMatrix[8] * 0.0;
-- 	b = modelViewMatrix[1] * 0.0 + modelViewMatrix[5] * m_wedgie + modelViewMatrix[9] * 0.0;
--@@ -248,13 +256,13 @@
-- 	r2sq = r2 * r2;
-- 	r3sq = r3 * r3;
-- 	
---	if (r1sq > csq) d1 = 2 / (r1sq - csq) * sqrt(pow(a * r1 - c * p1, 2) + pow(b * r1 - c * q1, 2));
--+	if (r1sq > csq + 0.01) d1 = 2 / (r1sq - csq) * sqrt(pow(a * r1 - c * p1, 2) + pow(b * r1 - c * q1, 2));
-- 	else d1 = DBL_MIN;
-- 	
---	if (r2sq > csq) d2 = 2 / (r2sq - csq) * sqrt(pow(a * r2 - c * p2, 2) + pow(b * r2 - c * q2, 2));
--+	if (r2sq > csq + 0.01) d2 = 2 / (r2sq - csq) * sqrt(pow(a * r2 - c * p2, 2) + pow(b * r2 - c * q2, 2));
-- 	else d2 = DBL_MIN;
-- 	
---	if (r3sq > csq) d3 = 2 / (r3sq - csq) * sqrt(pow(a * r3 - c * p3, 2) + pow(b * r3 - c * q3, 2));
--+	if (r3sq > csq + 0.01) d3 = 2 / (r3sq - csq) * sqrt(pow(a * r3 - c * p3, 2) + pow(b * r3 - c * q3, 2));
-- 	else d3 = DBL_MIN;
-- 		
-- // 	printf("%f %f %f\n", d1, d2, d3);
--@@ -262,8 +270,15 @@
-- 	m_priority = std::max(d1, d2);
-- 	m_priority = std::max(m_priority, d3);
-- 	
--+	printf("CP PRIO %.50f\n", m_priority, d1, d2, d3);
--+	if (m_priority > 500000)
--+	{
--+d1 = 0;
--+// 		return;
--+	}
--+	
-- 	// TODO usar un define o algo ese 1.0 es el ZNear
---// 	if (r1 >= -1.0 || r2 >= -1.0 || r3 >= -1.0) m_priority = DBL_MIN;
--+	if (r1sq < 1.0 || r2sq < 1.0 || r3sq < 1.0) m_priority = DBL_MIN;
-- 	
-- // 	if (d1 == d2 && d2 == d3 && d3 == 0) m_priority = DBL_MIN;
-- // 	qDebug("wedgie  %f prio %f", m_wedgie, m_priority);
--Index: libroam/map.h
--===================================================================
----- libroam/map.h	(revision 106)
--+++ libroam/map.h	(working copy)
--@@ -45,7 +45,7 @@
-- 		
-- 		void calcAmplitude();
-- 		
---	private:
--+// 	private:
-- 		void color(double height, int &r, int &g, int &b) const;
-- 	
-- 		std::vector<std::vector<double>*> m_heights;
--Index: glwidget.cpp
--===================================================================
----- glwidget.cpp	(revision 106)
--+++ glwidget.cpp	(working copy)
--@@ -80,9 +80,18 @@
-- 	if (m_roam.hasMap()) m_roam.paint();
-- 	swapBuffers();
-- }
---
--+// TODO quitame
--+#include "libroam/frustum.h"
--+#include "libroam/map.h"
--+#include "libroam/diamond.h"
-- void glWidget::keyPressEvent(QKeyEvent *e)
-- {
--+double modelViewMatrix[16], projectionMatrix[16];
--+			
--+			glGetDoublev(GL_MODELVIEW_MATRIX, modelViewMatrix);
--+			glGetDoublev(GL_PROJECTION_MATRIX, projectionMatrix);
--+			
--+			frustum f(projectionMatrix, modelViewMatrix);
-- 	switch(e->key())
-- 	{
-- 		case Qt::Key_Up:
--@@ -161,6 +170,16 @@
-- 			if (m_roam.hasMap()) m_roam.mergeOne();
-- 		break;
-- 		
--+		case Qt::Key_3:
--+			if (m_roam.hasMap()) m_roam.renew();
--+		break;
--+		
--+		case Qt::Key_4:
--+			f.setTriangleStatus(m_roam.m_map -> m_baseDiamond -> t1());
--+			f.setTriangleStatus(m_roam.m_map -> m_baseDiamond -> t2());
--+		break;
--+		
--+		
-- // 		case Key_3:
-- // 			for (int i = 0; i < 10; i++)
-- // 			{
-Index: libroam/roam.cpp
-===================================================================
---- libroam/roam.cpp	(revision 119)
-+++ libroam/roam.cpp	(working copy)
-@@ -82,6 +82,8 @@
- 	
- 
- 	frustum f = getFrustum();
-+	f.setTriangleStatus(d -> t1());
-+	f.setTriangleStatus(d -> t2());
- 	d -> t1() -> calcPriority(f);
- 	d -> t2() -> calcPriority(f);
- 	m_splitQueue -> insert(d -> t1());
-@@ -117,53 +119,59 @@
- 	
- 	frustum f = getFrustum();
- 	
--// 	newSplitQueue = new triangleList();
--// 	sqEndIt = m_splitQueue -> end();
--// 	for (sqIt = m_splitQueue -> begin(); sqIt != sqEndIt; ++sqIt)
--// 	{
--// 		t = (*sqIt).second;
--// 		t -> calcPriority(f);
--// 		newSplitQueue->insert(t);
--// 	}
--// // 	printf("%d %d\n", m_splitQueue->count(), newSplitQueue->count());
--// 	delete m_splitQueue;
--// 	m_splitQueue = newSplitQueue;
--// 	
--// 	newMergeQueue = new diamondList();
--// 	mqEndIt = m_mergeQueue -> end();
--// 	for (mqIt = m_mergeQueue -> begin(); mqIt != mqEndIt; ++mqIt)
--// 	{
--// 		d = (*mqIt).second;
--// 		d -> t1() -> calcPriority(f);
--// 		d -> t2() -> calcPriority(f);
--// 		newMergeQueue->insert(d);
--// 	}
--// // 	printf("%d %d\n", m_mergeQueue->count(), newMergeQueue->count());
--// 	delete m_mergeQueue;
--// 	m_mergeQueue = newMergeQueue;
--// 	
--// 	bool b = true;
--// 	while (m_map -> leaves() < 5000 ||
--// 	       (m_mergeQueue -> count() &&
--// 	       m_splitQueue -> last() -> priority() > m_mergeQueue -> first() -> priority()))
--// 	{
--// 		if (b) printf("ENTRAMOS\n");
--// 		b = false;
--// 		if (m_mergeQueue -> count()) printf("A partir: %f A fusionar: %f\n", m_splitQueue -> last() -> priority(), m_mergeQueue -> first() -> priority());
--// 		if (m_map -> leaves() < 5000)
--// 		{
--// 			printf("Partimos\n");
--// 			t = m_splitQueue -> last();
--// 			t -> split(m_splitQueue, m_mergeQueue, f);
--// 		}
--// 		else
--// 		{
--// 			printf("Fusionamos\n");
--// 			d = m_mergeQueue -> first();
--// 			d -> merge(m_splitQueue, m_mergeQueue);
--// 		}
--// 	}
-+	d = m_map -> baseDiamond();
-+	f.setTriangleStatus(d -> t1());
-+	f.setTriangleStatus(d -> t2());
-+	
-+	newSplitQueue = new triangleList();
-+	sqEndIt = m_splitQueue -> end();
-+	for (sqIt = m_splitQueue -> begin(); sqIt != sqEndIt; ++sqIt)
-+	{
-+		t = (*sqIt).second;
-+		t -> calcPriority(f);
-+		newSplitQueue->insert(t);
-+	}
-+// 	printf("%d %d\n", m_splitQueue->count(), newSplitQueue->count());
-+	delete m_splitQueue;
-+	m_splitQueue = newSplitQueue;
-+	
-+	newMergeQueue = new diamondList();
-+	mqEndIt = m_mergeQueue -> end();
-+	for (mqIt = m_mergeQueue -> begin(); mqIt != mqEndIt; ++mqIt)
-+	{
-+		d = (*mqIt).second;
-+		d -> t1() -> calcPriority(f);
-+		d -> t2() -> calcPriority(f);
-+		newMergeQueue->insert(d);
-+	}
-+// 	printf("%d %d\n", m_mergeQueue->count(), newMergeQueue->count());
-+	delete m_mergeQueue;
-+	m_mergeQueue = newMergeQueue;
-+	
-+	bool b = true;
-+	while (m_map -> leaves() < 5000 ||
-+	       (m_mergeQueue -> count() &&
-+	       m_splitQueue -> last() -> priority() > m_mergeQueue -> first() -> priority()))
-+	{
-+		if (b) printf("ENTRAMOS\n");
-+		b = false;
-+		if (m_mergeQueue -> count()) printf("A partir: %f A fusionar: %f\n", m_splitQueue -> last() -> priority(), m_mergeQueue -> first() -> priority());
-+		if (m_map -> leaves() < 5000)
-+		{
-+			printf("Partimos\n");
-+			t = m_splitQueue -> last();
-+			t -> split(m_splitQueue, m_mergeQueue, f);
-+		}
-+		else
-+		{
-+			printf("Fusionamos\n");
-+			d = m_mergeQueue -> first();
-+			d -> merge(m_splitQueue, m_mergeQueue, f);
-+		}
-+	}
- 
-+// 	renew();
-+
- 	glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
- 	glBegin(GL_TRIANGLES);
- 	paintTriangle(m_map -> baseDiamond() -> t1(), false);
-@@ -222,46 +230,45 @@
- void ROAM::splitOne()
- {
- 	triangle *t;
--	frustum f = getFrustum();
- 	t = m_splitQueue->last();
--	t -> split(m_splitQueue, m_mergeQueue, f);
-+	t -> split(m_splitQueue, m_mergeQueue, getFrustum());
- }
- 
- void ROAM::mergeOne()
- {
- 	diamond *d;
- 	d = m_mergeQueue->first();
--	d -> merge(m_splitQueue, m_mergeQueue);
-+	d -> merge(m_splitQueue, m_mergeQueue, getFrustum());
- }
- 
--void ROAM::renew()
--{
--	diamond *d = m_map -> baseDiamond();
--	
--	d->t1()->deleteLeaves(m_splitQueue);
--	d->t2()->deleteLeaves(m_splitQueue);
-+// void ROAM::renew()
-+// {
-+// 	diamond *d = m_map -> baseDiamond();
-+// 	
-+// 	d->t1()->deleteLeaves(m_splitQueue);
-+// 	d->t2()->deleteLeaves(m_splitQueue);
-+// 
-+// 	delete m_splitQueue;
-+// 	delete m_mergeQueue;
-+// 	
-+// 	m_splitQueue = new triangleList();
-+// 	m_mergeQueue = new diamondList();
-+// 	
-+// 	frustum f = getFrustum();
-+// 	
-+// 	d -> t1() -> calcPriority(f);
-+// 	d -> t2() -> calcPriority(f);
-+// 	m_splitQueue -> insert(d -> t1());
-+// 	m_splitQueue -> insert(d -> t2());
-+// 	
-+// 	triangle *t;
-+// 	for (int kk = 0; kk < 500; kk++)
-+// 	{
-+// 		t = m_splitQueue -> last();
-+// 		t -> split(m_splitQueue, m_mergeQueue, f);
-+// 	}
-+// }
- 
--	delete m_splitQueue;
--	delete m_mergeQueue;
--	
--	m_splitQueue = new triangleList();
--	m_mergeQueue = new diamondList();
--	
--	frustum f = getFrustum();
--	
--	d -> t1() -> calcPriority(f);
--	d -> t2() -> calcPriority(f);
--	m_splitQueue -> insert(d -> t1());
--	m_splitQueue -> insert(d -> t2());
--	
--	triangle *t;
--	for (int kk = 0; kk < 500; kk++)
--	{
--		t = m_splitQueue -> last();
--		t -> split(m_splitQueue, m_mergeQueue, f);
--	}
--}
--
- frustum ROAM::getFrustum() const
- {
- 	double modelViewMatrix[16], projectionMatrix[16];
-@@ -274,8 +281,8 @@
- {
- 	if (t -> isLeaf())
- 	{
--		if (t -> isVisible())
--		{
-+// 		if (t -> isVisible())
-+// 		{
- 			node *nodes[3];
- 			nodes[0] = t -> apex();
- 			nodes[1] = t -> rightVertex();
-@@ -290,7 +297,7 @@
- 				
- 				glVertex3dv(nodes[i] -> coords());
- 			}
--		}
-+// 		}
- 	}
- 	else
- 	{
-Index: libroam/roam.h
-===================================================================
---- libroam/roam.h	(revision 119)
-+++ libroam/roam.h	(working copy)
-@@ -44,7 +44,7 @@
- 		void mergeOne();
- 		void splitOne();
- 		
--		void renew();
-+// 		void renew();
- 		
- 	private:
- 		void clean();
-Index: libroam/triangle.cpp
-===================================================================
---- libroam/triangle.cpp	(revision 119)
-+++ libroam/triangle.cpp	(working copy)
-@@ -82,6 +82,7 @@
- 		delete m_rightTriangle;
- 		m_rightTriangle = 0;
- 		m_map.addLeaves(1);
-+		updateWedgie();
- 	}
- }
- 
-@@ -122,7 +123,8 @@
- 
- void triangle::updateWedgie()
- {
--	m_wedgie = m_ownWedgie + std::max(m_leftTriangle -> m_wedgie, m_rightTriangle -> m_wedgie);
-+	m_wedgie = m_ownWedgie;
-+	if (m_leftTriangle) m_wedgie += std::max(m_leftTriangle -> m_wedgie, m_rightTriangle -> m_wedgie);
- 	if (m_parentTriangle) m_parentTriangle -> updateWedgie();
- }
- 
-@@ -154,6 +156,8 @@
- 	// TODO place in other function?
- 	m_map.addTriangles(2);
- 	m_map.addLeaves(1);
-+	f.setTriangleStatus(m_leftTriangle);
-+	f.setTriangleStatus(m_rightTriangle);
- 	m_leftTriangle -> calcPriority(f);
- 	m_rightTriangle -> calcPriority(f);
- 	splitQueue->insert(m_leftTriangle);
-@@ -185,8 +189,8 @@
- 
- void triangle::calcPriority(const frustum &f)
- {
--	f.setTriangleStatus(this);
--	
-+	assert(m_status != UNKNOWN);
-+
- 	if (!isVisible())
- 	{
- 		m_priority = DBL_MIN;
-Index: libroam/frustum.cpp
-===================================================================
---- libroam/frustum.cpp	(revision 119)
-+++ libroam/frustum.cpp	(working copy)
-@@ -96,7 +96,7 @@
- 	else
- 	{
- 		int count = 0;
--		for (p = 0; p < 6; p++)
-+		for (p = 0; p < 4; p++)
- 		{
- 			int aux = 0;
- 			
-@@ -119,7 +119,7 @@
- 			}
- 		}
- 		
--		if (count == 6)
-+		if (count == 4)
- 		{
- 			// All three points are in front of all the planes
- 			s = triangle::COMPLETELYINSIDE;
-Index: libroam/triangle.h
-===================================================================
---- libroam/triangle.h	(revision 119)
-+++ libroam/triangle.h	(working copy)
-@@ -59,7 +59,7 @@
- 		FRUSTUMSTATUS frustumStatus() const;
- 		void setFrustumStatus(FRUSTUMSTATUS s);
- 	
--	private:
-+// 	private:
- 		r3vMap &m_map;
- 		
- 		node *m_apex;
-Index: libroam/diamond.cpp
-===================================================================
---- libroam/diamond.cpp	(revision 119)
-+++ libroam/diamond.cpp	(working copy)
-@@ -22,12 +22,22 @@
- 	delete m_t2;
- }
- 
--void diamond::merge(triangleList *splitQueue, diamondList *mergeQueue)
-+void diamond::merge(triangleList *splitQueue, diamondList *mergeQueue, const frustum &f)
- {
-+	// TODO  MIERDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA PQ NO ACTUALIZA LA PRIORIDAD???? PUES PQ NO SE LO DICES :-P
-+	printf("T1 %f %f\n", m_t1 -> m_wedgie, m_t1 -> m_priority);
-+	printf("T1HIJOS %f %f\n", m_t1 -> leftTriangle() -> m_priority, m_t1 -> rightTriangle() -> m_priority);
-+	printf("T2 %f %f\n", m_t2 -> m_wedgie, m_t2 -> m_priority);
-+	printf("T2HIJOS %f %f\n", m_t2 -> leftTriangle() -> m_priority, m_t2 -> rightTriangle() -> m_priority);
- 	m_t1 -> deleteLeaves(splitQueue);
- 	m_t2 -> deleteLeaves(splitQueue);
-+	// TODO  MIERDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA NI ACTUALIZANDO LA PRIORIDAD FUNCIONA
-+	m_t1 -> calcPriority(f);
-+	m_t2 -> calcPriority(f);
- 	splitQueue -> insert(m_t1);
- 	splitQueue -> insert(m_t2);
-+	printf("T1 %f %f\n", m_t1 -> m_wedgie, m_t1 -> m_priority);
-+	printf("T2 %f %f\n", m_t2 -> m_wedgie, m_t2 -> m_priority);
- 	mergeQueue -> remove(this);
- }
- 
-Index: libroam/diamond.h
-===================================================================
---- libroam/diamond.h	(revision 119)
-+++ libroam/diamond.h	(working copy)
-@@ -13,6 +13,7 @@
- #include "diamondlist.h"
- 
- class diamondList;
-+class frustum;
- class r3vMap;
- class triangle;
- class triangleList;
-@@ -23,7 +24,7 @@
- 		diamond(triangle *t1, triangle *t2);
- 		void clean();
- 		
--		void merge(triangleList *splitQueue, diamondList *mergeQueue);
-+		void merge(triangleList *splitQueue, diamondList *mergeQueue, const frustum &f);
- 		
- 		double priority() const;
- 		
-Index: glwidget.cpp
-===================================================================
---- glwidget.cpp	(revision 119)
-+++ glwidget.cpp	(working copy)
-@@ -170,9 +170,9 @@
- 			if (m_roam.hasMap()) m_roam.mergeOne();
- 		break;
- 		
--		case Qt::Key_3:
-+/*		case Qt::Key_3:
- 			if (m_roam.hasMap()) m_roam.renew();
--		break;
-+		break;*/
- 		
- // 		case Key_3:
- // 			for (int i = 0; i < 10; i++)
Index: libroam/roam.cpp
===================================================================
--- libroam/roam.cpp	(revision 119)
+++ libroam/roam.cpp	(working copy)
@@ -82,6 +82,8 @@
 	
 
 	frustum f = getFrustum();
+	f.setTriangleStatus(d -> t1());
+	f.setTriangleStatus(d -> t2());
 	d -> t1() -> calcPriority(f);
 	d -> t2() -> calcPriority(f);
 	m_splitQueue -> insert(d -> t1());
@@ -117,53 +119,61 @@
 	
 	frustum f = getFrustum();
 	
-// 	newSplitQueue = new triangleList();
-// 	sqEndIt = m_splitQueue -> end();
-// 	for (sqIt = m_splitQueue -> begin(); sqIt != sqEndIt; ++sqIt)
-// 	{
-// 		t = (*sqIt).second;
-// 		t -> calcPriority(f);
-// 		newSplitQueue->insert(t);
-// 	}
-// // 	printf("%d %d\n", m_splitQueue->count(), newSplitQueue->count());
-// 	delete m_splitQueue;
-// 	m_splitQueue = newSplitQueue;
-// 	
-// 	newMergeQueue = new diamondList();
-// 	mqEndIt = m_mergeQueue -> end();
-// 	for (mqIt = m_mergeQueue -> begin(); mqIt != mqEndIt; ++mqIt)
-// 	{
-// 		d = (*mqIt).second;
-// 		d -> t1() -> calcPriority(f);
-// 		d -> t2() -> calcPriority(f);
-// 		newMergeQueue->insert(d);
-// 	}
-// // 	printf("%d %d\n", m_mergeQueue->count(), newMergeQueue->count());
-// 	delete m_mergeQueue;
-// 	m_mergeQueue = newMergeQueue;
-// 	
-// 	bool b = true;
-// 	while (m_map -> leaves() < 5000 ||
-// 	       (m_mergeQueue -> count() &&
-// 	       m_splitQueue -> last() -> priority() > m_mergeQueue -> first() -> priority()))
-// 	{
-// 		if (b) printf("ENTRAMOS\n");
-// 		b = false;
-// 		if (m_mergeQueue -> count()) printf("A partir: %f A fusionar: %f\n", m_splitQueue -> last() -> priority(), m_mergeQueue -> first() -> priority());
-// 		if (m_map -> leaves() < 5000)
-// 		{
-// 			printf("Partimos\n");
-// 			t = m_splitQueue -> last();
-// 			t -> split(m_splitQueue, m_mergeQueue, f);
-// 		}
-// 		else
-// 		{
-// 			printf("Fusionamos\n");
-// 			d = m_mergeQueue -> first();
-// 			d -> merge(m_splitQueue, m_mergeQueue);
-// 		}
-// 	}
+	d = m_map -> baseDiamond();
+	f.setTriangleStatus(d -> t1());
+	f.setTriangleStatus(d -> t2());
+	
+	newSplitQueue = new triangleList();
+	sqEndIt = m_splitQueue -> end();
+	for (sqIt = m_splitQueue -> begin(); sqIt != sqEndIt; ++sqIt)
+	{
+		t = (*sqIt).second;
+		t -> calcPriority(f);
+		newSplitQueue->insert(t);
+	}
+// 	printf("%d %d\n", m_splitQueue->count(), newSplitQueue->count());
+	delete m_splitQueue;
+	m_splitQueue = newSplitQueue;
+	
+	newMergeQueue = new diamondList();
+	mqEndIt = m_mergeQueue -> end();
+	for (mqIt = m_mergeQueue -> begin(); mqIt != mqEndIt; ++mqIt)
+	{
+		d = (*mqIt).second;
+		d -> t1() -> calcPriority(f);
+		d -> t2() -> calcPriority(f);
+		newMergeQueue->insert(d);
+	}
+// 	printf("%d %d\n", m_mergeQueue->count(), newMergeQueue->count());
+	delete m_mergeQueue;
+	m_mergeQueue = newMergeQueue;
+	
+	printf("%d\n", m_mergeQueue -> count());
+	
+	bool b = true;
+	while (m_map -> leaves() < 5000 ||
+	       (m_mergeQueue -> count() &&
+	       m_splitQueue -> last() -> priority() > m_mergeQueue -> first() -> priority()))
+	{
+		if (b) printf("ENTRAMOS\n");
+		b = false;
+		if (m_mergeQueue -> count()) printf("A partir: %f A fusionar: %f\n", m_splitQueue -> last() -> priority(), m_mergeQueue -> first() -> priority());
+		if (m_map -> leaves() < 5000)
+		{
+			printf("Partimos\n");
+			t = m_splitQueue -> last();
+			t -> split(m_splitQueue, m_mergeQueue, f);
+		}
+		else
+		{
+			printf("Fusionamos\n");
+			d = m_mergeQueue -> first();
+			d -> merge(m_splitQueue, m_mergeQueue);
+		}
+	}
 
+// 	renew();
+
 	glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
 	glBegin(GL_TRIANGLES);
 	paintTriangle(m_map -> baseDiamond() -> t1(), false);
@@ -222,9 +232,8 @@
 void ROAM::splitOne()
 {
 	triangle *t;
-	frustum f = getFrustum();
 	t = m_splitQueue->last();
-	t -> split(m_splitQueue, m_mergeQueue, f);
+	t -> split(m_splitQueue, m_mergeQueue, getFrustum());
 }
 
 void ROAM::mergeOne()
@@ -234,34 +243,34 @@
 	d -> merge(m_splitQueue, m_mergeQueue);
 }
 
-void ROAM::renew()
-{
-	diamond *d = m_map -> baseDiamond();
-	
-	d->t1()->deleteLeaves(m_splitQueue);
-	d->t2()->deleteLeaves(m_splitQueue);
+// void ROAM::renew()
+// {
+// 	diamond *d = m_map -> baseDiamond();
+// 	
+// 	d->t1()->deleteLeaves(m_splitQueue);
+// 	d->t2()->deleteLeaves(m_splitQueue);
+// 
+// 	delete m_splitQueue;
+// 	delete m_mergeQueue;
+// 	
+// 	m_splitQueue = new triangleList();
+// 	m_mergeQueue = new diamondList();
+// 	
+// 	frustum f = getFrustum();
+// 	
+// 	d -> t1() -> calcPriority(f);
+// 	d -> t2() -> calcPriority(f);
+// 	m_splitQueue -> insert(d -> t1());
+// 	m_splitQueue -> insert(d -> t2());
+// 	
+// 	triangle *t;
+// 	for (int kk = 0; kk < 500; kk++)
+// 	{
+// 		t = m_splitQueue -> last();
+// 		t -> split(m_splitQueue, m_mergeQueue, f);
+// 	}
+// }
 
-	delete m_splitQueue;
-	delete m_mergeQueue;
-	
-	m_splitQueue = new triangleList();
-	m_mergeQueue = new diamondList();
-	
-	frustum f = getFrustum();
-	
-	d -> t1() -> calcPriority(f);
-	d -> t2() -> calcPriority(f);
-	m_splitQueue -> insert(d -> t1());
-	m_splitQueue -> insert(d -> t2());
-	
-	triangle *t;
-	for (int kk = 0; kk < 500; kk++)
-	{
-		t = m_splitQueue -> last();
-		t -> split(m_splitQueue, m_mergeQueue, f);
-	}
-}
-
 frustum ROAM::getFrustum() const
 {
 	double modelViewMatrix[16], projectionMatrix[16];
@@ -274,8 +283,8 @@
 {
 	if (t -> isLeaf())
 	{
-		if (t -> isVisible())
-		{
+// 		if (t -> isVisible())
+// 		{
 			node *nodes[3];
 			nodes[0] = t -> apex();
 			nodes[1] = t -> rightVertex();
@@ -290,7 +299,7 @@
 				
 				glVertex3dv(nodes[i] -> coords());
 			}
-		}
+// 		}
 	}
 	else
 	{
Index: libroam/roam.h
===================================================================
--- libroam/roam.h	(revision 119)
+++ libroam/roam.h	(working copy)
@@ -44,7 +44,7 @@
 		void mergeOne();
 		void splitOne();
 		
-		void renew();
+// 		void renew();
 		
 	private:
 		void clean();
Index: libroam/triangle.cpp
===================================================================
--- libroam/triangle.cpp	(revision 119)
+++ libroam/triangle.cpp	(working copy)
@@ -82,6 +82,7 @@
 		delete m_rightTriangle;
 		m_rightTriangle = 0;
 		m_map.addLeaves(1);
+		updateWedgie();
 	}
 }
 
@@ -122,7 +123,8 @@
 
 void triangle::updateWedgie()
 {
-	m_wedgie = m_ownWedgie + std::max(m_leftTriangle -> m_wedgie, m_rightTriangle -> m_wedgie);
+	m_wedgie = m_ownWedgie;
+	if (m_leftTriangle) m_wedgie += std::max(m_leftTriangle -> m_wedgie, m_rightTriangle -> m_wedgie);
 	if (m_parentTriangle) m_parentTriangle -> updateWedgie();
 }
 
@@ -154,6 +156,8 @@
 	// TODO place in other function?
 	m_map.addTriangles(2);
 	m_map.addLeaves(1);
+	f.setTriangleStatus(m_leftTriangle);
+	f.setTriangleStatus(m_rightTriangle);
 	m_leftTriangle -> calcPriority(f);
 	m_rightTriangle -> calcPriority(f);
 	splitQueue->insert(m_leftTriangle);
@@ -162,6 +166,9 @@
 	// baseTriangle -> m_leftTriangle to stop recurring splitting between base neighbours
 	if (baseTriangle && !baseTriangle -> m_leftTriangle) baseTriangle -> split(splitQueue, mergeQueue, f);
 	
+	updateWedgie();
+	calcPriority(f);
+	
 	if (m_parentTriangle) m_parentTriangle -> setMergeable(false, mergeQueue, baseTriangle);
 	if (baseTriangle)
 	{
@@ -174,8 +181,6 @@
 			setMergeable(true, mergeQueue, baseTriangle);
 		}
 	}
-	
-	updateWedgie();
 }
 
 double triangle::priority() const
@@ -185,8 +190,8 @@
 
 void triangle::calcPriority(const frustum &f)
 {
-	f.setTriangleStatus(this);
-	
+	assert(m_status != UNKNOWN);
+
 	if (!isVisible())
 	{
 		m_priority = DBL_MIN;
Index: libroam/frustum.cpp
===================================================================
--- libroam/frustum.cpp	(revision 119)
+++ libroam/frustum.cpp	(working copy)
@@ -96,7 +96,7 @@
 	else
 	{
 		int count = 0;
-		for (p = 0; p < 6; p++)
+		for (p = 0; p < 4; p++)
 		{
 			int aux = 0;
 			
@@ -119,7 +119,7 @@
 			}
 		}
 		
-		if (count == 6)
+		if (count == 4)
 		{
 			// All three points are in front of all the planes
 			s = triangle::COMPLETELYINSIDE;
Index: libroam/triangle.h
===================================================================
--- libroam/triangle.h	(revision 119)
+++ libroam/triangle.h	(working copy)
@@ -59,7 +59,7 @@
 		FRUSTUMSTATUS frustumStatus() const;
 		void setFrustumStatus(FRUSTUMSTATUS s);
 	
-	private:
+// 	private:
 		r3vMap &m_map;
 		
 		node *m_apex;
Index: glwidget.cpp
===================================================================
--- glwidget.cpp	(revision 119)
+++ glwidget.cpp	(working copy)
@@ -170,9 +170,9 @@
 			if (m_roam.hasMap()) m_roam.mergeOne();
 		break;
 		
-		case Qt::Key_3:
+/*		case Qt::Key_3:
 			if (m_roam.hasMap()) m_roam.renew();
-		break;
+		break;*/
 		
 // 		case Key_3:
 // 			for (int i = 0; i < 10; i++)
