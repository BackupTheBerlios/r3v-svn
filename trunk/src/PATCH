Index: libroam/roam.cpp
===================================================================
--- libroam/roam.cpp	(revision 112)
+++ libroam/roam.cpp	(working copy)
@@ -11,6 +11,7 @@
 #include "GL/glu.h"
 
 #include "diamond.h"
+#include "frustum.h"
 #include "map.h"
 #include "node.h"
 #include "roam.h"
@@ -79,8 +80,14 @@
 	m_splitQueue = new triangleList();
 	m_mergeQueue = new diamondList();
 	
-	double modelViewMatrix[16];
+	double modelViewMatrix[16], projectionMatrix[16];
 	glGetDoublev(GL_MODELVIEW_MATRIX, modelViewMatrix);
+	glGetDoublev(GL_PROJECTION_MATRIX, projectionMatrix);
+	frustum f(projectionMatrix, modelViewMatrix);
+	
+	f.setTriangleStatus(d -> t1());
+	f.setTriangleStatus(d -> t2());
+	
 	d -> t1() -> calcPriority(modelViewMatrix);
 	d -> t2() -> calcPriority(modelViewMatrix);
 	m_splitQueue -> insert(d -> t1());
@@ -123,53 +130,55 @@
 	
 	glGetDoublev(GL_MODELVIEW_MATRIX, modelViewMatrix);
 	
-	newSplitQueue = new triangleList();
-	sqEndIt = m_splitQueue -> end();
-	for (sqIt = m_splitQueue -> begin(); sqIt != sqEndIt; ++sqIt)
-	{
-		t = (*sqIt).second;
-		t -> calcPriority(modelViewMatrix);
-		newSplitQueue->insert(t);
-	}
-// 	printf("%d %d\n", m_splitQueue->count(), newSplitQueue->count());
-	delete m_splitQueue;
-	m_splitQueue = newSplitQueue;
-	
-	newMergeQueue = new diamondList();
-	mqEndIt = m_mergeQueue -> end();
-	for (mqIt = m_mergeQueue -> begin(); mqIt != mqEndIt; ++mqIt)
-	{
-		d = (*mqIt).second;
-		d -> t1() -> calcPriority(modelViewMatrix);
-		d -> t2() -> calcPriority(modelViewMatrix);
-		newMergeQueue->insert(d);
-	}
-// 	printf("%d %d\n", m_mergeQueue->count(), newMergeQueue->count());
-	delete m_mergeQueue;
-	m_mergeQueue = newMergeQueue;
-	
-	bool b = true;
-	while (m_map -> leaves() < 5000 ||
-	       (m_mergeQueue -> count() &&
-	       m_splitQueue -> last() -> priority() > m_mergeQueue -> first() -> priority()))
-	{
-		if (b) printf("ENTRAMOS\n");
-		b = false;
-		if (m_mergeQueue -> count()) printf("A partir: %f A fusionar: %f\n", m_splitQueue -> last() -> priority(), m_mergeQueue -> first() -> priority());
-		if (m_map -> leaves() < 5000)
-		{
-			printf("Partimos\n");
-			t = m_splitQueue -> last();
-			t -> split(m_splitQueue, m_mergeQueue, modelViewMatrix);
-		}
-		else
-		{
-			printf("Fusionamos\n");
-			d = m_mergeQueue -> first();
-			d -> merge(m_splitQueue, m_mergeQueue);
-		}
-	}
+// 	newSplitQueue = new triangleList();
+// 	sqEndIt = m_splitQueue -> end();
+// 	for (sqIt = m_splitQueue -> begin(); sqIt != sqEndIt; ++sqIt)
+// 	{
+// 		t = (*sqIt).second;
+// 		t -> calcPriority(modelViewMatrix);
+// 		newSplitQueue->insert(t);
+// 	}
+// // 	printf("%d %d\n", m_splitQueue->count(), newSplitQueue->count());
+// 	delete m_splitQueue;
+// 	m_splitQueue = newSplitQueue;
+// 	
+// 	newMergeQueue = new diamondList();
+// 	mqEndIt = m_mergeQueue -> end();
+// 	for (mqIt = m_mergeQueue -> begin(); mqIt != mqEndIt; ++mqIt)
+// 	{
+// 		d = (*mqIt).second;
+// 		d -> t1() -> calcPriority(modelViewMatrix);
+// 		d -> t2() -> calcPriority(modelViewMatrix);
+// 		newMergeQueue->insert(d);
+// 	}
+// // 	printf("%d %d\n", m_mergeQueue->count(), newMergeQueue->count());
+// 	delete m_mergeQueue;
+// 	m_mergeQueue = newMergeQueue;
+// 	
+// 	bool b = true;
+// 	while (m_map -> leaves() < 5000 ||
+// 	       (m_mergeQueue -> count() &&
+// 	       m_splitQueue -> last() -> priority() > m_mergeQueue -> first() -> priority()))
+// 	{
+// 		if (b) printf("ENTRAMOS\n");
+// 		b = false;
+// 		if (m_mergeQueue -> count()) printf("A partir: %f A fusionar: %f\n", m_splitQueue -> last() -> priority(), m_mergeQueue -> first() -> priority());
+// 		if (m_map -> leaves() < 5000)
+// 		{
+// 			printf("Partimos\n");
+// 			t = m_splitQueue -> last();
+// 			t -> split(m_splitQueue, m_mergeQueue, modelViewMatrix);
+// 		}
+// 		else
+// 		{
+// 			printf("Fusionamos\n");
+// 			d = m_mergeQueue -> first();
+// 			d -> merge(m_splitQueue, m_mergeQueue);
+// 		}
+// 	}
 
+// 	renew();
+
 	glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
 	glBegin(GL_TRIANGLES);
 	paintTriangle(m_map -> baseDiamond() -> t1(), false);
@@ -241,11 +250,45 @@
 	d -> merge(m_splitQueue, m_mergeQueue);
 }
 
+void ROAM::renew()
+{
+	diamond *d = m_map -> baseDiamond();
+	
+	d->t1()->deleteLeaves(m_splitQueue);
+	d->t2()->deleteLeaves(m_splitQueue);
+
+	delete m_splitQueue;
+	delete m_mergeQueue;
+	
+	m_splitQueue = new triangleList();
+	m_mergeQueue = new diamondList();
+	
+	double modelViewMatrix[16], projectionMatrix[16];
+	glGetDoublev(GL_MODELVIEW_MATRIX, modelViewMatrix);
+	glGetDoublev(GL_PROJECTION_MATRIX, projectionMatrix);
+	frustum f(projectionMatrix, modelViewMatrix);
+	
+	f.setTriangleStatus(d -> t1());
+	f.setTriangleStatus(d -> t2());
+	
+	d -> t1() -> calcPriority(modelViewMatrix);
+	d -> t2() -> calcPriority(modelViewMatrix);
+	m_splitQueue -> insert(d -> t1());
+	m_splitQueue -> insert(d -> t2());
+	
+	triangle *t;
+	for (int kk = 0; kk < 500; kk++)
+	{
+		t = m_splitQueue -> last();
+		t -> split(m_splitQueue, m_mergeQueue, modelViewMatrix);
+	}
+}
+
 void ROAM::paintTriangle(const triangle *t, bool color) const
 {
-	if (t -> isLeaf())
+	if (t -> isVisible())
 	{
-		if (t -> isVisible())
+		if (t -> isLeaf())
 		{
 			node *nodes[3];
 			nodes[0] = t -> apex();
@@ -262,10 +305,10 @@
 				glVertex3dv(nodes[i] -> coords());
 			}
 		}
+		else
+		{
+			paintTriangle(t -> leftTriangle(), color);
+			paintTriangle(t -> rightTriangle(), color);
+		}
 	}
-	else
-	{
-		paintTriangle(t -> leftTriangle(), color);
-		paintTriangle(t -> rightTriangle(), color);
-	}
 }
Index: libroam/roam.h
===================================================================
--- libroam/roam.h	(revision 106)
+++ libroam/roam.h	(working copy)
@@ -42,8 +42,9 @@
 		
 		void mergeOne();
 		void splitOne();
+		void renew();
 		
-	private:
+// 	private:
 		void clean();
 		void paintTriangle(const triangle *t, bool color) const;
 		
Index: libroam/triangle.cpp
===================================================================
--- libroam/triangle.cpp	(revision 111)
+++ libroam/triangle.cpp	(working copy)
@@ -72,14 +72,16 @@
 
 void triangle::deleteLeaves(triangleList *splitQueue)
 {
-// 	printf("%d\n", m_leftTriangle->m_level);
-	splitQueue -> remove(m_leftTriangle);
-	delete m_leftTriangle;
-	m_leftTriangle = 0;
-	splitQueue -> remove(m_rightTriangle);
-	delete m_rightTriangle;
-	m_rightTriangle = 0;
-	m_map.addLeaves(1);
+	if (m_leftTriangle)
+	{
+		splitQueue -> remove(m_leftTriangle);
+		delete m_leftTriangle;
+		m_leftTriangle = 0;
+		splitQueue -> remove(m_rightTriangle);
+		delete m_rightTriangle;
+		m_rightTriangle = 0;
+		m_map.addLeaves(1);
+	}
 }
 
 node *triangle::apex() const
@@ -127,6 +129,7 @@
 {
 // 	assert(!m_leftTriangle);
 // 	assert(!m_rightTriangle);
+	printf("Prioridad al hacer split %.50f\n", m_priority);
 	
 	splitQueue->remove(this);
 	
@@ -144,20 +147,11 @@
 	y = (m_leftVertex -> getZ() + m_rightVertex -> getZ()) / 2;
 	
 	node *newApex = m_map.getNode(x, y);
+	printf("%f %f %f\n", m_leftVertex -> getX(), m_rightVertex -> getX(), x);
+	printf("%f %f %f\n", m_leftVertex -> getZ(), m_rightVertex -> getZ(), y);
+	printf("%f\n", m_wedgie);
 	
-	/*
-	if (*newApex == *m_leftVertex)
-	{
-		printf("1\n");
-	}
-	else if (*m_apex == *newApex)
-	{
-		printf("2\n");
-	}
-	else if (*m_rightVertex == *m_leftVertex)
-	{
-		printf("3\n");
-	}*/
+	printf("%d %d %d %d\n", *newApex == *m_leftVertex, *m_apex == *newApex, *m_rightVertex == *m_leftVertex, *newApex == *m_rightVertex);
 	
 	m_leftTriangle = new triangle(m_map, newApex, m_apex, m_leftVertex, this);
 	m_rightTriangle = new triangle(m_map, newApex, m_rightVertex, m_apex, this);
@@ -175,11 +169,16 @@
 	if (m_parentTriangle) m_parentTriangle -> setMergeable(false, mergeQueue, baseTriangle);
 	if (baseTriangle)
 	{
+		assert(m_leftTriangle -> isLeaf());
+		assert(m_rightTriangle -> isLeaf());
+// 		printf("%lx %lx %d\n", baseTriangle, baseTriangle -> m_leftTriangle, baseTriangle -> m_leftTriangle -> isLeaf());
+		assert(baseTriangle -> m_leftTriangle -> isLeaf());
+		assert(baseTriangle -> m_rightTriangle -> isLeaf());
 		if (m_leftTriangle -> isLeaf() && m_rightTriangle -> isLeaf() && baseTriangle -> m_leftTriangle -> isLeaf() && baseTriangle -> m_rightTriangle -> isLeaf())
 		{
 			setMergeable(true, mergeQueue, baseTriangle);
 		}
-		else printf("NO PASA NUNCA\n");
+// 		else printf("%d %d %d %d\n", m_leftTriangle -> isLeaf(), m_rightTriangle -> isLeaf(), baseTriangle -> m_leftTriangle -> isLeaf(), baseTriangle -> m_rightTriangle -> isLeaf());
 	}
 	
 	updateWedgie();
@@ -194,6 +193,15 @@
 {
 // 	qDebug("%f %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f", modelViewMatrix[0], modelViewMatrix[1], modelViewMatrix[2], modelViewMatrix[3], modelViewMatrix[4], modelViewMatrix[5], modelViewMatrix[6], modelViewMatrix[7], modelViewMatrix[8], modelViewMatrix[9], modelViewMatrix[10], modelViewMatrix[11], modelViewMatrix[12], modelViewMatrix[13], modelViewMatrix[14], modelViewMatrix[15]);
 
+// 	assert(m_status != UNKNOWN);
+
+	printf("CP WEDGIE %.50f\n", m_wedgie);
+	if (m_wedgie < 0.05)
+	{
+		m_priority = 0;
+// 		return;
+	}
+
 	double a, b, c, p1, q1, r1, p2, q2, r2, p3, q3, r3, d1, d2, d3, csq, r1sq, r2sq, r3sq;
 	a = modelViewMatrix[0] * 0.0 + modelViewMatrix[4] * m_wedgie + modelViewMatrix[8] * 0.0;
 	b = modelViewMatrix[1] * 0.0 + modelViewMatrix[5] * m_wedgie + modelViewMatrix[9] * 0.0;
@@ -248,13 +256,13 @@
 	r2sq = r2 * r2;
 	r3sq = r3 * r3;
 	
-	if (r1sq > csq) d1 = 2 / (r1sq - csq) * sqrt(pow(a * r1 - c * p1, 2) + pow(b * r1 - c * q1, 2));
+	if (r1sq > csq + 0.01) d1 = 2 / (r1sq - csq) * sqrt(pow(a * r1 - c * p1, 2) + pow(b * r1 - c * q1, 2));
 	else d1 = DBL_MIN;
 	
-	if (r2sq > csq) d2 = 2 / (r2sq - csq) * sqrt(pow(a * r2 - c * p2, 2) + pow(b * r2 - c * q2, 2));
+	if (r2sq > csq + 0.01) d2 = 2 / (r2sq - csq) * sqrt(pow(a * r2 - c * p2, 2) + pow(b * r2 - c * q2, 2));
 	else d2 = DBL_MIN;
 	
-	if (r3sq > csq) d3 = 2 / (r3sq - csq) * sqrt(pow(a * r3 - c * p3, 2) + pow(b * r3 - c * q3, 2));
+	if (r3sq > csq + 0.01) d3 = 2 / (r3sq - csq) * sqrt(pow(a * r3 - c * p3, 2) + pow(b * r3 - c * q3, 2));
 	else d3 = DBL_MIN;
 		
 // 	printf("%f %f %f\n", d1, d2, d3);
@@ -262,8 +270,15 @@
 	m_priority = std::max(d1, d2);
 	m_priority = std::max(m_priority, d3);
 	
+	printf("CP PRIO %.50f\n", m_priority, d1, d2, d3);
+	if (m_priority > 500000)
+	{
+d1 = 0;
+// 		return;
+	}
+	
 	// TODO usar un define o algo ese 1.0 es el ZNear
-// 	if (r1 >= -1.0 || r2 >= -1.0 || r3 >= -1.0) m_priority = DBL_MIN;
+	if (r1sq < 1.0 || r2sq < 1.0 || r3sq < 1.0) m_priority = DBL_MIN;
 	
 // 	if (d1 == d2 && d2 == d3 && d3 == 0) m_priority = DBL_MIN;
 // 	qDebug("wedgie  %f prio %f", m_wedgie, m_priority);
Index: libroam/map.h
===================================================================
--- libroam/map.h	(revision 106)
+++ libroam/map.h	(working copy)
@@ -45,7 +45,7 @@
 		
 		void calcAmplitude();
 		
-	private:
+// 	private:
 		void color(double height, int &r, int &g, int &b) const;
 	
 		std::vector<std::vector<double>*> m_heights;
Index: glwidget.cpp
===================================================================
--- glwidget.cpp	(revision 106)
+++ glwidget.cpp	(working copy)
@@ -80,9 +80,18 @@
 	if (m_roam.hasMap()) m_roam.paint();
 	swapBuffers();
 }
-
+// TODO quitame
+#include "libroam/frustum.h"
+#include "libroam/map.h"
+#include "libroam/diamond.h"
 void glWidget::keyPressEvent(QKeyEvent *e)
 {
+double modelViewMatrix[16], projectionMatrix[16];
+			
+			glGetDoublev(GL_MODELVIEW_MATRIX, modelViewMatrix);
+			glGetDoublev(GL_PROJECTION_MATRIX, projectionMatrix);
+			
+			frustum f(projectionMatrix, modelViewMatrix);
 	switch(e->key())
 	{
 		case Qt::Key_Up:
@@ -161,6 +170,16 @@
 			if (m_roam.hasMap()) m_roam.mergeOne();
 		break;
 		
+		case Qt::Key_3:
+			if (m_roam.hasMap()) m_roam.renew();
+		break;
+		
+		case Qt::Key_4:
+			f.setTriangleStatus(m_roam.m_map -> m_baseDiamond -> t1());
+			f.setTriangleStatus(m_roam.m_map -> m_baseDiamond -> t2());
+		break;
+		
+		
 // 		case Key_3:
 // 			for (int i = 0; i < 10; i++)
 // 			{
